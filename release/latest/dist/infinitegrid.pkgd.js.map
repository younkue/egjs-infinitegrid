{"version":3,"file":"infinitegrid.pkgd.js","sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 0495506d9df970b55422","webpack:///./src/browser.js","webpack:///./src/index.umd.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///./src/consts.js","webpack:///./src/utils.js","webpack:///./src/ItemManager.js","webpack:///./src/DOMRenderer.js","webpack:///./src/Watcher.js","webpack:///./src/Infinite.js","webpack:///./src/AutoSizer.js","webpack:///./src/ImageLoaded.js","webpack:///./src/LayoutManager.js","webpack:///./src/InfiniteGrid.js","webpack:///./src/layouts/GridLayout.js","webpack:///./src/layouts/FrameLayout.js","webpack:///./src/layouts/SquareLayout.js","webpack:///./src/layouts/lib/BoxModel.js","webpack:///./src/layouts/PackingLayout.js","webpack:///./src/layouts/lib/dijkstra.js","webpack:///./src/layouts/JustifiedLayout.js","webpack:///./src/index.js","webpack:///./node_modules/@egjs/component/dist/component.module.js","webpack:///(webpack)/buildin/global.js","webpack:///./src/version.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"InfiniteGrid\"] = factory();\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"InfiniteGrid\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 0495506d9df970b55422","/* eslint-disable no-new-func, no-nested-ternary */\nif (typeof window === \"undefined\") {\n  global.window = {\n    document: {},\n    navigator: {\n      userAgent: \"\"\n    }\n  };\n}\n\nconst win = window;\n/* eslint-enable no-new-func, no-nested-ternary */\n\nexport { win as window };\nexport const document = win.document;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/browser.js\n// module id = 0\n// module chunks = 0 1","/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\nimport InfiniteGrid, * as modules from \"./index\";\n\nfor (const name in modules) {\n  InfiniteGrid[name] = modules[name];\n}\n\nmodule.exports = InfiniteGrid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.umd.js\n// module id = 1\n// module chunks = 0 1","module.exports = function(originalModule) {\r\n\tif(!originalModule.webpackPolyfill) {\r\n\t\tvar module = Object.create(originalModule);\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"exports\", {\r\n\t\t\tenumerable: true,\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/harmony-module.js\n// module id = 2\n// module chunks = 0 1","import { window, document } from \"./browser\";\nconst ua = window.navigator.userAgent;\nexport const SUPPORT_COMPUTEDSTYLE = !!(\"getComputedStyle\" in window);\nexport const SUPPORT_ADDEVENTLISTENER = !!(\"addEventListener\" in document);\nexport const SUPPORT_PASSIVE = (() => {\n  let supportsPassiveOption = false;\n\n  try {\n    if (SUPPORT_ADDEVENTLISTENER && Object.defineProperty) {\n      document.addEventListener(\"test\", null, Object.defineProperty({}, \"passive\", {\n        get() {\n          supportsPassiveOption = true;\n        }\n\n      }));\n    }\n  } catch (e) {}\n\n  return supportsPassiveOption;\n})();\nexport const IS_IE = /MSIE|Trident|Windows Phone|Edge/.test(ua);\nexport const IS_IOS = /iPhone|iPad/.test(ua);\nexport const IS_ANDROID2 = /Android 2\\./.test(ua);\nexport const CONTAINER_CLASSNAME = \"_eg-infinitegrid-container_\";\nexport const IGNORE_CLASSNAME = \"_eg-infinitegrid-ignore_\";\nexport const TRANSITION_NAME = \"_INFINITEGRID_TRANSITION\";\nexport const APPEND = true;\nexport const PREPEND = false;\nexport const VERTICAL = \"vertical\";\nexport const HORIZONTAL = \"horizontal\";\nexport const CACHE = true;\nexport const NO_CACHE = false;\nexport const TRUSTED = true;\nexport const NO_TRUSTED = false;\nexport const MULTI = true;\nexport const SINGLE = false;\nexport const DUMMY_POSITION = -100000;\nexport const GROUPKEY_ATT = \"data-groupkey\";\nexport const DEFAULT_OPTIONS = {\n  horizontal: false,\n  margin: 0\n};\nexport const agent = ua.toLowerCase();\nexport const isMobile = /mobi|ios|android/.test(agent);\nexport const ALIGN = {\n  START: \"start\",\n  CENTER: \"center\",\n  END: \"end\",\n  JUSTIFY: \"justify\"\n};\nexport const IDLE = 0;\nexport const LOADING_APPEND = 1;\nexport const LOADING_PREPEND = 2;\nexport const PROCESSING = 4;\nconst webkit = /applewebkit\\/([\\d|.]*)/g.exec(agent);\nexport const WEBKIT_VERSION = webkit && parseInt(webkit[1], 10) || 0;\nexport const DEFENSE_BROWSER = WEBKIT_VERSION && WEBKIT_VERSION < 537;\nexport const [TRANSFORM, TRANSITION, TRANSITION_END] = function () {\n  const properties = {\n    transitionend: \"\",\n    webkitTransitionEnd: \"-webkit-\",\n    oTransitionEnd: \"-o-\",\n    mozTransitionEnd: \"-moz-\"\n  };\n\n  for (const property in properties) {\n    const prefix = properties[property];\n\n    if (`on${property.toLowerCase()}` in window) {\n      return [`${prefix}transform`, `${prefix}transition`, property];\n    }\n  }\n\n  return [];\n}();\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/consts.js\n// module id = null\n// module chunks = ","import { window, document } from \"./browser\";\nimport { SUPPORT_COMPUTEDSTYLE, SUPPORT_ADDEVENTLISTENER, SUPPORT_PASSIVE, VERTICAL, HORIZONTAL, DEFAULT_OPTIONS } from \"./consts\";\nexport function toArray(nodes) {\n  // SCRIPT5014 in IE8\n  const array = [];\n\n  if (nodes) {\n    for (let i = 0, len = nodes.length; i < len; i++) {\n      array.push(nodes[i]);\n    }\n  }\n\n  return array;\n}\nexport function matchHTML(html) {\n  return html.match(/^<([A-z]+)\\s*([^>]*)>/);\n}\n/**\n * Select or create element\n * @param {String|HTMLElement|jQuery} param\n *  when string given is as HTML tag, then create element\n *  otherwise it returns selected elements\n * @param {Boolean} multi\n * @returns {HTMLElement}\n */\n\nexport function $(param, multi = false) {\n  let el;\n\n  if (typeof param === \"string\") {\n    // String (HTML, Selector)\n    // check if string is HTML tag format\n    const match = matchHTML(param); // creating element\n\n    if (match) {\n      // HTML\n      const dummy = document.createElement(\"div\");\n      dummy.innerHTML = param;\n      el = dummy.childNodes;\n    } else {\n      // Selector\n      el = document.querySelectorAll(param);\n    }\n\n    if (multi) {\n      el = toArray(el);\n    } else {\n      el = el && el.length > 0 && el[0] || undefined;\n    }\n  } else if (param === window) {\n    // window\n    el = param;\n  } else if (param.nodeName && (param.nodeType === 1 || param.nodeType === 9)) {\n    // HTMLElement, Document\n    el = param;\n  } else if (\"jQuery\" in window && param instanceof window.jQuery || param.constructor.prototype.jquery) {\n    // jQuery\n    el = $(multi ? param.toArray() : param.get(0), multi);\n  } else if (Array.isArray(param)) {\n    el = param.map(v => $(v));\n\n    if (!multi) {\n      el = el.length >= 1 ? el[0] : undefined;\n    }\n  }\n\n  return el;\n}\nexport function addEvent(element, type, handler, eventListenerOptions) {\n  if (SUPPORT_ADDEVENTLISTENER) {\n    let options = eventListenerOptions || false;\n\n    if (typeof eventListenerOptions === \"object\") {\n      options = SUPPORT_PASSIVE ? eventListenerOptions : false;\n    }\n\n    element.addEventListener(type, handler, options);\n  } else if (element.attachEvent) {\n    element.attachEvent(`on${type}`, handler);\n  } else {\n    element[`on${type}`] = handler;\n  }\n}\nexport function removeEvent(element, type, handler) {\n  if (element.removeEventListener) {\n    element.removeEventListener(type, handler, false);\n  } else if (element.detachEvent) {\n    element.detachEvent(`on${type}`, handler);\n  } else {\n    element[`on${type}`] = null;\n  }\n}\nexport function addOnceEvent(element, type, handler, eventListenerOptions) {\n  const callback = e => {\n    removeEvent(element, type, callback);\n    handler(e);\n  };\n\n  addEvent(element, type, callback, eventListenerOptions);\n}\nexport function scroll(el, horizontal = false) {\n  const prop = `scroll${horizontal ? \"Left\" : \"Top\"}`;\n\n  if (el === window) {\n    return window[horizontal ? \"pageXOffset\" : \"pageYOffset\"] || document.body[prop] || document.documentElement[prop];\n  } else {\n    return el[prop];\n  }\n}\nexport function scrollTo(el, x, y) {\n  if (el === window) {\n    el.scroll(x, y);\n  } else {\n    el.scrollLeft = x;\n    el.scrollTop = y;\n  }\n}\nexport function scrollBy(el, x, y) {\n  if (el === window) {\n    el.scrollBy(x, y);\n  } else {\n    el.scrollLeft += x;\n    el.scrollTop += y;\n  }\n}\nexport function getStyles(el) {\n  return (SUPPORT_COMPUTEDSTYLE ? window.getComputedStyle(el) : el.currentStyle) || {};\n}\n\nfunction _getSize(el, name, isOffset) {\n  if (el === window) {\n    // WINDOW\n    return window[`inner${name}`] || document.body[`client${name}`];\n  } else if (el.nodeType === 9) {\n    // DOCUMENT_NODE\n    const doc = el.documentElement;\n    return Math.max(el.body[`scroll${name}`], doc[`scroll${name}`], el.body[`offset${name}`], doc[`offset${name}`], doc[`client${name}`]);\n  } else {\n    // NODE\n    let size = 0;\n\n    if (isOffset) {\n      const clientRect = el.getBoundingClientRect();\n      size = name === \"Width\" ? clientRect.right - clientRect.left : clientRect.bottom - clientRect.top;\n    } else {\n      size = el[`client${name}`] || el[`offset${name}`];\n    }\n\n    return parseFloat(size || getStyles(el)[name.toLowerCase()]) || 0;\n  }\n}\n\nexport function innerWidth(el) {\n  return _getSize(el, \"Width\", false);\n}\nexport function innerHeight(el) {\n  return _getSize(el, \"Height\", false);\n}\nexport function outerWidth(el) {\n  return _getSize(el, \"Width\", true);\n}\nexport function outerHeight(el) {\n  return _getSize(el, \"Height\", true);\n}\nexport function getSize(el) {\n  return {\n    width: outerWidth(el),\n    height: outerHeight(el)\n  };\n}\nexport const STYLE = {\n  vertical: {\n    pos1: \"top\",\n    endPos1: \"bottom\",\n    size1: \"height\",\n    pos2: \"left\",\n    endPos2: \"right\",\n    size2: \"width\"\n  },\n  horizontal: {\n    pos1: \"left\",\n    endPos1: \"right\",\n    size1: \"width\",\n    pos2: \"top\",\n    endPos2: \"bottom\",\n    size2: \"height\"\n  }\n};\nexport function getStyleNames(isHorizontal) {\n  return STYLE[isHorizontal ? HORIZONTAL : VERTICAL];\n}\nexport function assignOptions(defaultOptions, options) {\n  return Object.assign({}, DEFAULT_OPTIONS, defaultOptions, options);\n}\nexport function toZeroArray(outline) {\n  if (!outline || !outline.length) {\n    return [0];\n  }\n\n  return outline;\n}\nexport function cloneItems(items) {\n  return items.map(item => Object.assign({}, item));\n}\nexport function isWindow(el) {\n  return el === window;\n}\nexport function fill(arr, value) {\n  const length = arr.length;\n\n  for (let i = length - 1; i >= 0; --i) {\n    arr[i] = value;\n  }\n\n  return arr;\n}\nexport function isUndefined(target) {\n  return typeof target === \"undefined\";\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils.js\n// module id = null\n// module chunks = ","import { MULTI, GROUPKEY_ATT, IGNORE_CLASSNAME, DUMMY_POSITION } from \"./consts\";\nimport { $, toArray, isUndefined } from \"./utils\";\nexport default class ItemManager {\n  static from(elements, selector, {\n    groupKey,\n    isAppend\n  }) {\n    const filted = ItemManager.selectItems($(elements, MULTI), selector); // Item Structure\n\n    return toArray(filted).map(el => ({\n      el,\n      groupKey,\n      content: el.outerHTML,\n      rect: {\n        top: DUMMY_POSITION,\n        left: DUMMY_POSITION\n      }\n    }));\n  }\n\n  static selectItems(elements, selector) {\n    return elements.filter(v => {\n      const classNames = v.className.split(\" \");\n\n      if (classNames.some(c => c === IGNORE_CLASSNAME)) {\n        return false;\n      } else if (!selector || selector === \"*\") {\n        return v;\n      } else {\n        return classNames.some(c => c === selector);\n      }\n    });\n  }\n\n  static pluck(data, property) {\n    return data.reduce((acc, v) => acc.concat(v[property]), []);\n  }\n\n  constructor() {\n    this.clear();\n  }\n\n  getStatus(startKey, endKey) {\n    const datas = this._data;\n    const startIndex = Math.max(this.indexOf(startKey), 0);\n    const endIndex = this.indexOf(endKey) + 1 || datas.length;\n    return {\n      _data: datas.slice(startIndex, endIndex).map(data => {\n        const items = data.items.map(item => {\n          const item2 = Object.assign({}, item);\n          delete item2.el;\n          return item2;\n        });\n        const data2 = Object.assign({}, data);\n        data2.items = items;\n        return data2;\n      })\n    };\n  }\n\n  setStatus(status) {\n    const data = status._data;\n    this.set(data);\n  }\n\n  size() {\n    return this._data.length;\n  }\n\n  fit(base, horizontal) {\n    if (!this._data.length) {\n      return;\n    }\n\n    const property = horizontal ? \"left\" : \"top\";\n\n    if (base !== 0) {\n      this._data = this._data.map(v => {\n        v.items = v.items.map(item => {\n          item.rect[property] -= base;\n          return item;\n        });\n        v.outlines.start = v.outlines.start.map(start => start - base);\n        v.outlines.end = v.outlines.end.map(end => end - base);\n        return v;\n      });\n    }\n  }\n\n  pluck(property, start, end) {\n    const data = isUndefined(start) ? this._data : this._data.slice(start, (isUndefined(end) ? start : end) + 1);\n    return ItemManager.pluck(data, property);\n  }\n\n  getOutline(index, property) {\n    const data = this._data[index];\n    return data ? data.outlines[property] : [];\n  }\n\n  getEdgeIndex(cursor, start, end) {\n    const prop = cursor === \"start\" ? \"min\" : \"max\";\n    let index = -1;\n    let targetValue = cursor === \"start\" ? Infinity : -Infinity;\n\n    for (let i = start; i <= end; i++) {\n      const value = Math[prop](...this.getOutline(i, cursor));\n\n      if (cursor === \"start\" && targetValue > value || cursor === \"end\" && targetValue < value) {\n        targetValue = value;\n        index = i;\n      }\n    }\n\n    return index;\n  }\n\n  getEdgeValue(cursor, start, end) {\n    const outlines = this.pluck(\"outlines\", this.getEdgeIndex(cursor, start, end)).reduce((acc, v) => acc.concat(v[cursor]), []);\n    return outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"](...outlines) : 0;\n  }\n\n  clearOutlines(startCursor = -1, endCursor = -1) {\n    const datas = this.get();\n    datas.forEach((group, cursor) => {\n      if (startCursor <= cursor && cursor <= endCursor) {\n        return;\n      }\n\n      group.items.forEach(item => {\n        item.rect.top = DUMMY_POSITION;\n        item.rect.left = DUMMY_POSITION;\n      });\n      group.outlines.start = [];\n      group.outlines.end = [];\n    });\n  }\n\n  getMaxEdgeValue() {\n    const groups = this.get();\n    const length = groups.length;\n\n    for (let i = length - 1; i >= 0; --i) {\n      const end = groups[i].outlines.end;\n\n      if (end.length) {\n        const pos = Math.max(...end);\n        return pos;\n      }\n    }\n\n    return 0;\n  }\n\n  append(layouted) {\n    this._data.push(layouted);\n\n    return layouted.items;\n  }\n\n  prepend(layouted) {\n    this._data.unshift(layouted);\n\n    return layouted.items;\n  }\n\n  clear() {\n    this._data = [];\n  }\n\n  remove(element, start, end) {\n    let items = [];\n    const key = element.getAttribute(GROUPKEY_ATT);\n    let data = this.get(start, end).filter(v => String(v.groupKey) === key);\n\n    if (!data.length) {\n      return items;\n    }\n\n    data = data[0];\n    const len = data.items.length;\n    let idx = -1;\n\n    for (let i = 0; i < len; i++) {\n      if (data.items[i].el === element) {\n        idx = i;\n        break;\n      }\n    }\n\n    if (~idx) {\n      // remove item information\n      data.items.splice(idx, 1);\n      this.set(data, key);\n      items = data.items;\n    }\n\n    return items;\n  }\n\n  indexOf(data) {\n    const groupKey = typeof data === \"object\" ? data.groupKey : data;\n    const datas = this._data;\n    const length = datas.length;\n\n    for (let i = 0; i < length; ++i) {\n      if (groupKey === datas[i].groupKey) {\n        return i;\n      }\n    }\n\n    return -1;\n  }\n\n  get(start, end) {\n    return isUndefined(start) ? this._data : this._data.slice(start, (isUndefined(end) ? start : end) + 1);\n  }\n\n  set(data, key) {\n    if (!isUndefined(key) && !Array.isArray(data)) {\n      const len = this._data.length;\n      let idx = -1;\n\n      for (let i = 0; i < len; i++) {\n        if (this._data[i].groupKey === key) {\n          idx = i;\n          break;\n        }\n      }\n\n      ~idx && (this._data[idx] = data);\n    } else {\n      this._data = data.concat();\n    }\n  }\n\n  getData(index) {\n    return this._data[index];\n  }\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ItemManager.js\n// module id = null\n// module chunks = ","import { APPEND, PREPEND, DUMMY_POSITION, MULTI, GROUPKEY_ATT, CONTAINER_CLASSNAME, TRANSITION_NAME, TRANSITION, TRANSITION_END, TRANSFORM } from \"./consts\";\nimport { window, document } from \"./browser\";\nimport { $, innerHeight, innerWidth, getSize, getStyles, addOnceEvent } from \"./utils\";\n\nfunction createContainer(element) {\n  const container = document.createElement(\"div\");\n  container.className = CONTAINER_CLASSNAME;\n  container.style.position = \"relative\";\n  container.style.height = \"100%\";\n  const children = element.children;\n  const length = children.length; // for IE8\n\n  for (let i = 0; i < length; i++) {\n    container.appendChild(children[0]);\n  }\n\n  element.appendChild(container);\n  return container;\n}\n\nfunction render(properties, rect, styles) {\n  properties.forEach(p => {\n    p in rect && (styles[p] = `${rect[p]}px`);\n  });\n}\n\nfunction setTransition(styles, transitionDuration, pos1, pos2) {\n  styles[`${TRANSITION}-property`] = transitionDuration ? `${TRANSFORM},width,height` : \"\";\n  styles[`${TRANSITION}-duration`] = transitionDuration ? `${transitionDuration}s` : \"\";\n  styles[`${TRANSITION}-delay`] = transitionDuration ? `0s` : \"\";\n  styles[TRANSFORM] = transitionDuration ? `translate(${pos1.left - pos2.left}px,${pos1.top - pos2.top}px)` : \"\";\n}\n\nexport default class DOMRenderer {\n  static renderItem(item, rect, transitionDuration) {\n    if (!item.el) {\n      return;\n    }\n\n    const {\n      el,\n      prevRect\n    } = item;\n    const styles = el.style; // for debugging\n\n    el.setAttribute(GROUPKEY_ATT, item.groupKey);\n    styles.position = \"absolute\";\n    render([\"width\", \"height\"], rect, styles);\n\n    if (transitionDuration && TRANSITION && prevRect) {\n      setTransition(styles, transitionDuration, rect, prevRect);\n\n      if (el[TRANSITION_NAME]) {\n        return;\n      }\n\n      el[TRANSITION_NAME] = true;\n      addOnceEvent(el, TRANSITION_END, () => {\n        const itemRect = item.rect;\n        setTransition(styles);\n        render([\"left\", \"top\"], itemRect, styles);\n        item.prevRect = itemRect;\n        el[TRANSITION_NAME] = false;\n      });\n    } else {\n      render([\"left\", \"top\"], rect, styles);\n      item.prevRect = rect;\n    }\n  }\n\n  static renderItems(items, transitionDuration) {\n    items.forEach(item => {\n      DOMRenderer.renderItem(item, item.rect, transitionDuration);\n    });\n  }\n\n  static removeItems(items) {\n    items.forEach(item => {\n      if (item.el) {\n        DOMRenderer.removeElement(item.el);\n        item.el = null;\n      }\n    });\n  }\n\n  static removeElement(element) {\n    const parentNode = element && element.parentNode;\n\n    if (!parentNode) {\n      return;\n    }\n\n    parentNode.removeChild(element);\n  }\n\n  static createElements(items) {\n    if (!items.length) {\n      return;\n    }\n\n    const noElementItems = items.filter(item => !item.el);\n\n    if (!noElementItems.length) {\n      return;\n    }\n\n    const elements = $(noElementItems.map(({\n      content\n    }) => content.replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, \"\")).join(\"\"), MULTI);\n    noElementItems.forEach((item, index) => {\n      item.el = elements[index];\n    });\n  }\n\n  constructor(element, options) {\n    Object.assign(this.options = {\n      isEqualSize: false,\n      isConstantSize: false,\n      horizontal: false,\n      container: false\n    }, options);\n    this._size = {\n      container: -1,\n      view: -1,\n      viewport: -1,\n      item: null\n    };\n\n    this._init(element);\n\n    this.resize();\n  }\n\n  getStatus() {\n    return {\n      cssText: this.container.style.cssText,\n      _size: Object.assign({}, this._size)\n    };\n  }\n\n  setStatus(status) {\n    this.container.style.cssText = status.cssText;\n    Object.assign(this._size, status._size);\n  }\n\n  updateSize(items) {\n    const {\n      isEqualSize,\n      isConstantSize\n    } = this.options;\n    const size = this._size;\n    return items.map(item => {\n      if (!item.el) {\n        return item;\n      }\n\n      if (isEqualSize && !size.item) {\n        size.item = getSize(item.el);\n      }\n\n      item.size = isEqualSize && Object.assign(size.item) || isConstantSize && item.orgSize && Object.assign(item.orgSize) || getSize(item.el);\n\n      if (!item.orgSize) {\n        item.orgSize = Object.assign({}, item.size);\n      }\n\n      return item;\n    });\n  }\n\n  _init(el) {\n    const element = $(el);\n    const style = getStyles(element);\n    const {\n      container,\n      horizontal\n    } = this.options;\n    this._orgStyle = {};\n\n    if (style.position === \"static\") {\n      this._orgStyle.position = element.style.position;\n      element.style.position = \"relative\";\n    }\n\n    if (container) {\n      const target = horizontal ? [\"X\", \"Y\"] : [\"Y\", \"X\"];\n      this._orgStyle.overflowX = element.style.overflowX;\n      this._orgStyle.overflowY = element.style.overflowY;\n      element.style[`overflow${target[0]}`] = \"scroll\";\n      element.style[`overflow${target[1]}`] = \"hidden\";\n      this.view = element;\n      this.container = container === true ? createContainer(this.view) : container;\n    } else {\n      this.view = window;\n      this.container = element;\n    }\n  }\n\n  append(items) {\n    this._insert(items, APPEND, {\n      top: DUMMY_POSITION,\n      left: DUMMY_POSITION\n    });\n  }\n\n  prepend(items) {\n    this._insert(items, PREPEND, {\n      top: DUMMY_POSITION,\n      left: DUMMY_POSITION\n    });\n  }\n\n  createAndInsert(items, isAppend) {\n    DOMRenderer.createElements(items);\n    DOMRenderer.renderItems(items);\n\n    this._insert(items, isAppend);\n  }\n\n  _insert(items, isAppend, styles) {\n    const container = this.container;\n    const df = document.createDocumentFragment();\n    items.forEach(item => {\n      styles && DOMRenderer.renderItem(item, styles);\n      isAppend ? df.appendChild(item.el) : df.insertBefore(item.el, df.firstChild);\n    });\n    isAppend ? container.appendChild(df) : container.insertBefore(df, container.firstChild);\n  }\n\n  _calcSize() {\n    return this.options.horizontal ? innerHeight(this.container) : innerWidth(this.container);\n  }\n\n  getViewSize() {\n    return this._size.view;\n  }\n\n  getViewportSize() {\n    return this._size.viewport;\n  }\n\n  setContainerSize(size) {\n    this.container.style[this.options.horizontal ? \"width\" : \"height\"] = `${size}px`;\n  }\n\n  resize() {\n    const horizontal = this.options.horizontal;\n    const view = this.view;\n    const isResize = this.isNeededResize();\n\n    if (isResize) {\n      this._size = {\n        viewport: this._calcSize(),\n        item: null\n      };\n    }\n\n    this._size.view = horizontal ? innerWidth(view) : innerHeight(view);\n    return isResize;\n  }\n\n  isNeededResize() {\n    return this._calcSize() !== this._size.viewport;\n  }\n\n  clear() {\n    this.container.innerHTML = \"\";\n    this.container.style[this.options.horizontal ? \"width\" : \"height\"] = \"\";\n    this._size = {\n      item: null,\n      viewport: -1,\n      container: -1,\n      view: -1\n    };\n  }\n\n  destroy() {\n    this.clear();\n    const container = this.options.container;\n\n    for (const p in this._orgStyle) {\n      this[container ? \"view\" : \"container\"].style[p] = this._orgStyle[p];\n    }\n\n    container && this.container.parentNode.removeChild(this.container);\n  }\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/DOMRenderer.js\n// module id = null\n// module chunks = ","import { IS_IOS } from \"./consts\";\nimport { addEvent, removeEvent, scroll, scrollTo, scrollBy } from \"./utils\";\nexport default class Watcher {\n  constructor(view, options) {\n    Object.assign(this.options = {\n      container: view,\n      resize: () => {},\n      check: () => {},\n      isOverflowScroll: false,\n      horizontal: false\n    }, options);\n    this._timer = {\n      resize: null // doubleCheck: null,\n      // doubleCheckCount: RETRY,\n\n    };\n    this.reset();\n    this._containerOffset = 0;\n    this._view = view;\n    this._scrollIssue = IS_IOS;\n    this._onCheck = this._onCheck.bind(this);\n    this._onResize = this._onResize.bind(this);\n    this.attachEvent();\n    this.setScrollPos();\n    this.resize();\n  }\n\n  getStatus() {\n    return {\n      _prevPos: this._prevPos,\n      scrollPos: this.getOrgScrollPos()\n    };\n  }\n\n  setStatus(status, applyScrollPos = true) {\n    this._prevPos = status._prevPos;\n    applyScrollPos && this.scrollTo(status.scrollPos);\n  }\n\n  scrollBy(pos) {\n    const arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n    scrollBy(this._view, ...arrPos);\n    this.setScrollPos();\n  }\n\n  scrollTo(pos) {\n    const arrPos = this.options.horizontal ? [pos, 0] : [0, pos];\n    scrollTo(this._view, ...arrPos);\n  }\n\n  getScrollPos() {\n    return this._prevPos;\n  }\n\n  setScrollPos(pos) {\n    let rawPos = pos;\n\n    if (typeof pos === \"undefined\") {\n      rawPos = this.getOrgScrollPos();\n    }\n\n    this._prevPos = rawPos - this.getContainerOffset();\n  }\n\n  attachEvent() {\n    addEvent(this._view, \"scroll\", this._onCheck);\n    addEvent(window, \"resize\", this._onResize);\n  }\n\n  getOrgScrollPos() {\n    return scroll(this._view, this.options.horizontal);\n  }\n\n  reset() {\n    this._prevPos = null;\n  }\n\n  _onCheck() {\n    const prevPos = this.getScrollPos();\n    const orgScrollPos = this.getOrgScrollPos();\n    this.setScrollPos(orgScrollPos);\n    const scrollPos = this.getScrollPos();\n\n    if (prevPos === null || this._scrollIssue && orgScrollPos === 0 || prevPos === scrollPos) {\n      orgScrollPos && (this._scrollIssue = false);\n      return;\n    }\n\n    this._scrollIssue = false;\n    this.options.check({\n      isForward: prevPos < scrollPos,\n      scrollPos,\n      orgScrollPos,\n      horizontal: this.options.horizontal\n    });\n  }\n\n  getContainerOffset() {\n    return this._containerOffset;\n  }\n\n  _getOffset() {\n    const {\n      container,\n      horizontal\n    } = this.options;\n    const rect = container.getBoundingClientRect();\n    return rect[horizontal ? \"left\" : \"top\"] + this.getOrgScrollPos();\n  }\n\n  resize() {\n    this._containerOffset = this.options.isOverflowScroll ? 0 : this._getOffset();\n  }\n\n  _onResize() {\n    if (this._timer.resize) {\n      clearTimeout(this._timer.resize);\n    }\n\n    this._timer.resize = setTimeout(() => {\n      this.resize();\n      this.options.resize();\n      this._timer.resize = null;\n      this.reset();\n    }, 100);\n  }\n\n  detachEvent() {\n    removeEvent(this._view, \"scroll\", this._onCheck);\n    removeEvent(window, \"resize\", this._onResize);\n  }\n\n  destroy() {\n    this.detachEvent();\n    this.reset();\n  }\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Watcher.js\n// module id = null\n// module chunks = ","function isVisible(group, threshold, scrollPos, endScrollPos) {\n  const {\n    items,\n    outlines\n  } = group;\n  const start = outlines.start;\n  const end = outlines.end;\n\n  if (start.legnth === 0 || end.length === 0 || !items.length || !items[0].el) {\n    return 2;\n  }\n\n  const min = Math.min(...start);\n  const max = Math.max(...end);\n\n  if (endScrollPos + threshold < min) {\n    return +1;\n  } else if (scrollPos - threshold > max) {\n    return -1;\n  }\n\n  return 0;\n}\n\nclass Infinite {\n  constructor(itemManger, options) {\n    this.options = Object.assign({\n      useRecycle: true,\n      threshold: 100,\n      append: () => {},\n      prepend: () => {},\n      recycle: () => {}\n    }, options);\n    this._items = itemManger;\n    this.clear();\n  }\n\n  setSize(size) {\n    this._status.size = size;\n  }\n\n  recycle(scrollPos, isForward) {\n    if (!this.options.useRecycle) {\n      return;\n    }\n\n    const {\n      startCursor,\n      endCursor,\n      size\n    } = this._status;\n\n    if (startCursor === -1 || endCursor === -1) {\n      return;\n    }\n\n    const endScrollPos = scrollPos + size;\n    const {\n      threshold,\n      recycle\n    } = this.options;\n\n    const visibles = this._items.get(startCursor, endCursor).map(group => isVisible(group, threshold, scrollPos, endScrollPos));\n\n    const length = visibles.length;\n    let start = isForward ? 0 : visibles.lastIndexOf(0);\n    let end = isForward ? visibles.indexOf(0) - 1 : visibles.length - 1;\n\n    if (!isForward && start !== -1) {\n      start += 1;\n    }\n\n    if (start < 0 || end < 0 || start > end || end - start + 1 >= length) {\n      return;\n    }\n\n    start = startCursor + start;\n    end = startCursor + end;\n    recycle({\n      start,\n      end\n    });\n\n    if (isForward) {\n      this.setCursor(\"start\", end + 1);\n    } else {\n      this.setCursor(\"end\", start - 1);\n    }\n  }\n\n  scroll(scrollPos) {\n    const startCursor = this.getCursor(\"start\");\n    const endCursor = this.getCursor(\"end\");\n    const items = this._items;\n\n    if (typeof scrollPos !== \"number\" || startCursor === -1 || endCursor === -1 || !items.size()) {\n      return;\n    }\n\n    const size = this._status.size;\n    const {\n      threshold,\n      append,\n      prepend\n    } = this.options;\n    const datas = items.get();\n    const endScrollPos = Math.max(scrollPos, 0) + size;\n    const startEdgePos = Math.max(...datas[startCursor].outlines.start);\n    const endEdgePos = Math.min(...datas[endCursor].outlines.end);\n    const visibles = datas.map((group, i) => {\n      const {\n        start,\n        end\n      } = group.outlines;\n\n      if (!start.length || !end.length) {\n        return false;\n      }\n\n      const startPos = Math.min(...start);\n      const endPos = Math.max(...end);\n\n      if (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {\n        return true;\n      }\n\n      return false;\n    });\n    const start = visibles.indexOf(true);\n    const end = visibles.lastIndexOf(true);\n\n    if (~start && start < startCursor) {\n      prepend({\n        cache: datas.slice(start, Math.min(startCursor, end + 1))\n      });\n    } else if (endCursor < end) {\n      append({\n        cache: datas.slice(Math.max(start, endCursor + 1), end + 1)\n      });\n    } else if (endScrollPos >= endEdgePos - threshold) {\n      append({\n        cache: datas.slice(endCursor + 1, endCursor + 2)\n      });\n    } else if (scrollPos <= startEdgePos + threshold) {\n      prepend({\n        cache: datas.slice(startCursor - 1, startCursor)\n      });\n    }\n  }\n\n  setCursor(cursor, index) {\n    const status = this._status;\n    const items = this._items;\n    const size = items.size();\n\n    if (!this.options.useRecycle) {\n      status.startCursor = 0;\n\n      if (items.getOutline(size - 1, \"end\").length) {\n        status.endCursor = size - 1;\n        return;\n      }\n\n      if (cursor !== \"end\") {\n        return;\n      }\n    }\n\n    if (cursor === \"start\") {\n      status.startCursor = index;\n    } else {\n      status.endCursor = Math.min(size - 1, index);\n    }\n\n    status.startCursor = Math.max(0, status.startCursor);\n  }\n\n  setStatus(status) {\n    this._status = Object.assign(this._status, status);\n  }\n\n  getStatus(startKey, endKey) {\n    const {\n      startCursor,\n      endCursor,\n      size\n    } = this._status;\n    const startIndex = Math.max(this._items.indexOf(startKey), 0);\n    const endIndex = (this._items.indexOf(endKey) + 1 || this._items.size()) - 1;\n    const start = Math.max(startCursor - startIndex, ~startCursor ? 0 : -1);\n    const end = Math.max(Math.min(endCursor - startIndex, endIndex - startIndex), start);\n    return {\n      startCursor: start,\n      endCursor: end,\n      size\n    };\n  }\n\n  getEdgeOutline(cursor) {\n    const {\n      startCursor,\n      endCursor\n    } = this._status;\n\n    if (startCursor === -1 || endCursor === -1) {\n      return [];\n    }\n\n    return this._items.getOutline(cursor === \"start\" ? startCursor : endCursor, cursor);\n  }\n\n  getEdgeValue(cursor) {\n    const outlines = this.getEdgeOutline(cursor);\n    return outlines.length ? Math[cursor === \"start\" ? \"min\" : \"max\"](...outlines) : 0;\n  }\n\n  getVisibleItems() {\n    return this._items.pluck(\"items\", this._status.startCursor, this._status.endCursor);\n  }\n\n  getCursor(cursor) {\n    return this._status[cursor === \"start\" ? \"startCursor\" : \"endCursor\"];\n  }\n\n  getVisibleData() {\n    return this._items.get(this._status.startCursor, this._status.endCursor);\n  }\n\n  remove(element) {\n    return this._items.remove(element, this._status.startCursor, this._status.endCursor);\n  }\n\n  clear() {\n    this._status = {\n      startCursor: -1,\n      endCursor: -1,\n      size: -1\n    };\n  }\n\n}\n\nexport default Infinite;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/Infinite.js\n// module id = null\n// module chunks = ","import { window } from \"./browser\";\nimport { addEvent, removeEvent, innerWidth, innerHeight } from \"./utils\";\nconst elements = [];\n/* eslint-disable */\n\nfunction onResize(e) {\n  AutoSizer.resizeAll();\n}\n/* eslint-enable */\n\n\nexport default class AutoSizer {\n  static add(element, prefix = \"data-\") {\n    if (!element.length) {\n      addEvent(window, \"resize\", onResize);\n    }\n\n    element.__PREFIX__ = prefix;\n    elements.push(element);\n    AutoSizer.resize(element);\n  }\n\n  static remove(element, isFixed = false) {\n    const fixed = element.getAttribute(`${element.__PREFIX__}fixed`) || \"width\";\n\n    if (!isFixed) {\n      element.style[fixed === \"width\" ? \"height\" : \"width\"] = \"\";\n    }\n\n    const index = elements.indexOf(element);\n\n    if (!~index) {\n      return;\n    }\n\n    elements.splice(index, 1);\n\n    if (!elements.length) {\n      removeEvent(window, \"reisze\", onResize);\n    }\n  }\n\n  static resize(element, prefix = \"data-\") {\n    const elementPrefix = typeof element.__PREFIX__ === \"string\" ? element.__PREFIX__ : prefix;\n    const dataWidth = element.getAttribute(`${elementPrefix}width`);\n    const dataHeight = element.getAttribute(`${elementPrefix}height`);\n    const fixed = element.getAttribute(`${elementPrefix}fixed`);\n\n    if (fixed === \"height\") {\n      const size = innerHeight(element) || dataHeight;\n      element.style.width = `${dataWidth / dataHeight * size}px`;\n    } else {\n      const size = innerWidth(element) || dataWidth;\n      element.style.height = `${dataHeight / dataWidth * size}px`;\n    }\n  }\n\n  static resizeAll() {\n    elements.forEach(element => AutoSizer.resize(element));\n  }\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/AutoSizer.js\n// module id = null\n// module chunks = ","import { IS_IE } from \"./consts\";\nimport { addEvent, removeEvent, toArray } from \"./utils\";\nimport AutoSizer from \"./AutoSizer\";\nexport const CHECK_ALL = 1;\nexport const CHECK_ONLY_ERROR = 2;\n\nfunction isDataAttribute(target, prefix) {\n  return !!target.getAttribute(`${prefix}width`);\n}\n\nclass ImageLoaded {\n  static waitImageLoaded(needCheck, {\n    prefix = \"\",\n    length,\n    type,\n    complete,\n    error,\n    end\n  }) {\n    let checkCount = 0;\n    let endCount = length;\n\n    if (type !== CHECK_ONLY_ERROR) {\n      checkCount = endCount;\n    }\n\n    const checkEnd = function () {\n      if (--endCount !== 0) {\n        return;\n      }\n\n      end && end();\n    };\n\n    const checkImage = function () {\n      checkCount--;\n\n      if (checkCount !== 0) {\n        return;\n      }\n\n      complete && complete();\n    };\n\n    const onError = function (target, itemIndex = target.__ITEM_INDEX__) {\n      error && error({\n        target,\n        itemIndex\n      });\n    };\n\n    const onCheck = function (e) {\n      const target = e.target || e.srcElement;\n      removeEvent(target, \"error\", onCheck);\n      removeEvent(target, \"load\", onCheck);\n\n      if (type === CHECK_ALL && isDataAttribute(target, prefix)) {\n        AutoSizer.remove(target, e.type === \"error\");\n      } else {\n        checkImage();\n      }\n\n      if (e.type === \"error\") {\n        onError(target);\n      }\n\n      delete target.__ITEM_INDEX__;\n      checkEnd();\n    };\n\n    needCheck.forEach((images, i) => {\n      images.forEach(v => {\n        // workaround for IE\n        if (v.complete && (!IS_IE || IS_IE && v.naturalWidth)) {\n          if (!v.naturalWidth) {\n            onError(v, i);\n          }\n\n          checkImage();\n          checkEnd();\n          return;\n        }\n\n        v.__ITEM_INDEX__ = i;\n\n        if (type === CHECK_ALL && isDataAttribute(v, prefix)) {\n          AutoSizer.add(v, prefix);\n          checkImage();\n        }\n\n        addEvent(v, \"load\", onCheck);\n        addEvent(v, \"error\", onCheck);\n        IS_IE && v.setAttribute(\"src\", v.getAttribute(\"src\"));\n      });\n    });\n  }\n\n  static checkImageLoaded(el) {\n    if (el.tagName === \"IMG\") {\n      return el.complete ? [] : [el];\n    } else {\n      return toArray(el.querySelectorAll(\"img\"));\n    }\n  }\n\n  static check(elements, {\n    prefix,\n    type = CHECK_ALL,\n    complete,\n    error,\n    end\n  }) {\n    const images = elements.map(element => this.checkImageLoaded(element));\n    const length = images.reduce((sum, element) => sum + element.length, 0);\n\n    if (type === CHECK_ONLY_ERROR || length === 0) {\n      // convert to async\n      setTimeout(() => {\n        complete && complete();\n\n        if (length === 0) {\n          end && end();\n        }\n      }, 0);\n    }\n\n    if (length > 0) {\n      setTimeout(() => {\n        this.waitImageLoaded(images, {\n          prefix,\n          length,\n          type,\n          complete,\n          error,\n          end\n        });\n      }, 0);\n    }\n  }\n\n}\n\nexport default ImageLoaded;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ImageLoaded.js\n// module id = null\n// module chunks = ","import AutoSizer from \"./AutoSizer\";\nimport ImageLoaded, { CHECK_ALL, CHECK_ONLY_ERROR } from \"./ImageLoaded\";\nimport ItemManager from \"./ItemManager\";\nimport { matchHTML, $ } from \"./utils\";\nimport { DUMMY_POSITION } from \"./consts\";\nimport DOMRenderer from \"./DOMRenderer\";\n\nfunction hasTarget(target, value) {\n  return ~target.indexOf(value);\n}\n\nexport default class LayoutMananger {\n  constructor(items, renderer, options = {}) {\n    Object.assign(this.options = {\n      attributePrefix: \"data-\",\n      isEqualSize: false,\n      isConstantSize: false,\n      horizontal: false\n    }, options);\n    this._items = items;\n    this._renderer = renderer;\n    this._layout = null;\n  }\n\n  setLayout(layout) {\n    this._layout = layout;\n  }\n\n  setSize(size) {\n    this._layout.setSize(size);\n  }\n\n  _complete(groups, items, isAppend, isUpdate, callback) {\n    const itemManager = this._items;\n    const cursor = isAppend ? \"end\" : \"start\";\n    const groupIndex = itemManager.indexOf(groups[0]);\n    const prevGroup = itemManager.getData(groupIndex + (isAppend ? -1 : 1));\n    let outline = prevGroup ? prevGroup.outlines[cursor] : [0];\n\n    this._renderer.updateSize(items);\n\n    const groupInfos = groups.map(group => {\n      const groupOutline = group.outlines[isAppend ? \"start\" : \"end\"];\n      const isRelayout = isUpdate || !outline.length || (outline.length === groupOutline.length ? !outline.every((v, index) => v === groupOutline[index]) : true);\n\n      if (!isRelayout) {\n        outline = group.outlines[isAppend ? \"end\" : \"start\"];\n        DOMRenderer.renderItems(group.items);\n        return group;\n      }\n\n      const groupItems = group.items;\n\n      const groupInfo = this._layout[isAppend ? \"append\" : \"prepend\"](groupItems, outline, true);\n\n      Object.assign(group, groupInfo);\n      DOMRenderer.renderItems(groupInfo.items);\n      outline = groupInfo.outlines[isAppend ? \"end\" : \"start\"];\n      return groupInfo;\n    });\n    callback({\n      groups: groupInfos,\n      items,\n      isAppend\n    });\n  }\n\n  _error(removeTarget, replaceTarget, target, items, errorIndex, callback) {\n    const item = items[errorIndex];\n    const element = item.el;\n    const prefix = this.options.attributePrefix; // remove item\n\n    const removeItem = () => {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      removeTarget.push(element);\n      const index = replaceTarget.indexOf(errorIndex);\n      index !== -1 && replaceTarget.splice(index, 1);\n    }; // remove image\n\n\n    const remove = () => {\n      if (target === element) {\n        removeItem();\n        return;\n      }\n\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      target.parentNode.removeChild(target);\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    }; // replace image\n\n\n    const replace = src => {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      if (src) {\n        if (matchHTML(src) || typeof src === \"object\") {\n          const parentNode = target.parentNode;\n          parentNode.insertBefore($(src), target);\n          parentNode.removeChild(target);\n          item.content = element.outerHTML;\n        } else {\n          target.src = src;\n\n          if (target.getAttribute(`${prefix}width`)) {\n            AutoSizer.remove(target);\n            target.removeAttribute(`${prefix}width`);\n            target.removeAttribute(`${prefix}height`);\n          }\n        }\n      }\n\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    }; // replace item\n\n\n    const replaceItem = content => {\n      if (hasTarget(removeTarget, element)) {\n        return;\n      }\n\n      element.innerHTML = content;\n      item.content = element.outerHTML;\n\n      if (hasTarget(replaceTarget, errorIndex)) {\n        return;\n      }\n\n      replaceTarget.push(errorIndex);\n    };\n\n    callback({\n      target,\n      element,\n      items,\n      item,\n      itemIndex: errorIndex,\n      replace,\n      replaceItem,\n      remove,\n      removeItem\n    });\n  }\n\n  _end(removeTarget, replaceTarget, items, callback) {\n    const {\n      attributePrefix\n    } = this.options;\n    const removeTargetLength = removeTarget.length;\n    const replaceTargetLength = replaceTarget.length;\n\n    if (!removeTargetLength && !replaceTargetLength) {\n      callback({\n        remove: []\n      });\n      return;\n    }\n\n    const layoutedItems = replaceTarget.map(itemIndex => items[itemIndex]);\n\n    if (!replaceTargetLength) {\n      callback({\n        remove: removeTarget,\n        layout: true\n      });\n      return;\n    } // wait layoutComplete beacause of error event.\n\n\n    ImageLoaded.check(layoutedItems.map(v => v.el), {\n      prefix: attributePrefix,\n      complete: () => {\n        this._renderer.updateSize(layoutedItems);\n\n        callback({\n          remove: removeTarget,\n          layout: true\n        });\n      }\n    });\n  }\n\n  _insert({\n    groups,\n    items = ItemManager.pluck(groups, \"items\"),\n    isAppend,\n    isUpdate\n  }, {\n    error = () => {},\n    complete = () => {},\n    end = () => {}\n  }) {\n    if (!groups.length) {\n      return;\n    }\n\n    const checkGroups = isAppend ? groups : groups.reverse();\n    const replaceTarget = [];\n    const removeTarget = [];\n    const elements = items.map(item => item.el);\n    const type = this.options.isEqualSize && this._renderer._size.item ? CHECK_ONLY_ERROR : CHECK_ALL;\n    const prefix = this.options.attributePrefix;\n    ImageLoaded.check(elements, {\n      prefix,\n      type,\n      complete: () => {\n        if (!this._items) {\n          return;\n        }\n\n        this._complete(checkGroups, items, isAppend, isUpdate, complete);\n      },\n      error: ({\n        target,\n        itemIndex\n      }) => {\n        if (!this._items) {\n          return;\n        }\n\n        this._error(removeTarget, replaceTarget, target, items, itemIndex, error);\n      },\n      end: () => {\n        if (!this._items) {\n          return;\n        }\n\n        this._end(removeTarget, replaceTarget, items, end);\n      }\n    });\n  }\n\n  append({\n    groups,\n    items,\n    isUpdate\n  }, callbacks = {}) {\n    this._insert({\n      groups,\n      items,\n      isUpdate,\n      isAppend: true\n    }, callbacks);\n  }\n\n  prepend({\n    groups,\n    items,\n    isUpdate\n  }, callbacks = {}) {\n    this._insert({\n      groups,\n      items,\n      isUpdate,\n      isAppend: false\n    }, callbacks);\n  }\n\n  layout(isRelayout, groups, items) {\n    const renderer = this._renderer;\n    const {\n      isConstantSize\n    } = renderer.options;\n    const layoutGroups = groups.filter(group => {\n      const item = group.items[0];\n      return item.orgSize && item.rect.top > DUMMY_POSITION / 10;\n    });\n\n    if (!layoutGroups.length) {\n      return [];\n    }\n\n    let outline = layoutGroups[0].outlines.start;\n\n    if (isRelayout) {\n      outline = [outline.length ? Math.min(...outline) : 0];\n\n      if (!isConstantSize && items.length) {\n        renderer.updateSize(items);\n      }\n    }\n\n    this._layout.layout(layoutGroups, outline);\n\n    return layoutGroups;\n  }\n\n  destroy() {\n    this._items = null;\n    this._renderer = null;\n  }\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/LayoutManager.js\n// module id = null\n// module chunks = ","/**\n * Copyright (c) 2017 NAVER Corp.\n * egjs projects are licensed under the MIT license\n*/\nimport Component from \"@egjs/component\";\nimport ItemManager from \"./ItemManager\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport Watcher from \"./Watcher\";\nimport { APPEND, PREPEND, CACHE, NO_CACHE, TRUSTED, NO_TRUSTED, IS_ANDROID2, IDLE, LOADING_APPEND, LOADING_PREPEND, PROCESSING, DEFENSE_BROWSER, IGNORE_CLASSNAME, DUMMY_POSITION } from \"./consts\";\nimport Infinite from \"./Infinite\";\nimport { toArray, $, outerHeight, outerWidth } from \"./utils\";\nimport LayoutMananger from \"./LayoutManager\"; // IE8\n// https://stackoverflow.com/questions/43216659/babel-ie8-inherit-issue-with-object-create\n\n/* eslint-disable */\n\nif (typeof Object.create !== \"function\") {\n  Object.create = function (o, properties) {\n    if (typeof o !== \"object\" && typeof o !== \"function\") {\n      throw new TypeError(\"Object prototype may only be an Object: \" + o);\n    } else if (o === null) {\n      throw new Error(\"This browser's implementation of Object.create is a shim and doesn't support 'null' as the first argument.\");\n    }\n\n    function F() {}\n\n    F.prototype = o;\n    return new F();\n  };\n}\n/* eslint-enable */\n\n/**\n * A module used to arrange card elements including content infinitely according to layout type. With this module, you can implement various layouts composed of different card elements whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko          .         .        DOM      \n * @alias eg.InfiniteGrid\n * @extends eg.Component\n *\n * @example\n```\n<ul id=\"grid\">\n\t<li class=\"card\">\n\t\t<div>test1</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test2</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test3</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test4</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test5</div>\n\t</li>\n\t<li class=\"card\">\n\t\t<div>test6</div>\n\t</li>\n</ul>\n<script>\nvar some = new eg.InfiniteGrid(\"#grid\").on(\"layoutComplete\", function(e) {\n\t// ...\n});\n\n// If you already have items in the container, call \"layout\" method.\nsome.layout();\n</script>\n```\n *\n * @support {\"ie\": \"8+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n **/\n\n\nclass InfiniteGrid extends Component {\n  /**\n   * @param {HTMLElement|String|jQuery} element A base element for a module <ko>   </ko>\n   * @param {Object} [options] The option object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n   * @param {String} [options.itemSelector] A selector to select card elements that make up the layout<ko>     (selector)</ko>\n   * @param {Boolean} [options.useRecycle=true] Indicates whether keep the number of DOMs is maintained. If the useRecycle value is 'true', keep the number of DOMs is maintained. If the useRecycle value is 'false', the number of DOMs will increase as card elements are added. <ko>DOM    . useRecycle  'true' DOM   . useRecycle  'false'     DOM   .</ko>\n   * @param {Boolean} [options.isOverflowScroll=false] Indicates whether overflow:scroll is applied<ko>overflow:scroll  .</ko>\n   * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false )</ko>\n   * @param {Boolean} [options.useFit=true] The useFit option scrolls upwards so that no space is visible until an item is added <ko>          .</ko>\n   * @param {Boolean} [options.isEqualSize=false] Indicates whether sizes of all card elements are equal to one another. If sizes of card elements to be arranged are all equal and this option is set to \"true\", the performance of layout arrangement can be improved. <ko>    .          'true'       </ko>\n   * @param {Boolean} [options.isConstantSize=false] Indicates whether sizes of all card elements does not change, the performance of layout arrangement can be improved. <ko>        'true'       </ko>\n   * @param {Number} [options.transitionDruation=0] Indicates how many seconds a transition effect takes to complete. <ko>     .</ko>\n   * @param {Number} [options.threshold=100] The threshold size of an event area where card elements are added to a layout.<ko>        .</ko>\n   * @param {String} [options.attributePrefix=\"data-\"] The prefix to use element's data attribute.<ko>    .</ko>\n   */\n  constructor(element, options) {\n    super();\n    Object.assign(this.options = {\n      itemSelector: \"*\",\n      isOverflowScroll: false,\n      threshold: 100,\n      isEqualSize: false,\n      isConstantSize: false,\n      useRecycle: true,\n      horizontal: false,\n      transitionDuration: 0,\n      useFit: true,\n      attributePrefix: \"data-\"\n    }, options);\n    DEFENSE_BROWSER && (this.options.useFit = false);\n    IS_ANDROID2 && (this.options.isOverflowScroll = false);\n\n    this._reset();\n\n    this._loadingBar = {};\n    const {\n      isOverflowScroll,\n      isEqualSize,\n      isConstantSize,\n      horizontal,\n      threshold,\n      useRecycle\n    } = this.options;\n    this._items = new ItemManager();\n    this._renderer = new DOMRenderer(element, {\n      isEqualSize,\n      isConstantSize,\n      horizontal,\n      container: isOverflowScroll\n    });\n    this._watcher = new Watcher(this._renderer.view, {\n      isOverflowScroll,\n      horizontal,\n      container: this._renderer.container,\n      resize: () => this._onResize(),\n      check: param => this._onCheck(param)\n    });\n    this._infinite = new Infinite(this._items, {\n      horizontal,\n      useRecycle,\n      threshold,\n      append: param => this._requestAppend(param),\n      prepend: param => this._requestPrepend(param),\n      recycle: param => this._recycle(param)\n    });\n  }\n  /**\n   * Adds a card element at the bottom of a layout. This method is available only if the isProcessing() method returns false.\n   * @ko     . isProcessing()   'false'      \n   *   isProcessing()  false   .\n   * @param {Array|jQuery} elements Array of the card elements to be added <ko>   </ko>\n   * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n   * <ko>     .    .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.append(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n   * infinitegrid.append([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n   * infinitegrid.append([HTMLElement1, HTMLElement2]);\n   * infinitegrid.append(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n   */\n\n\n  append(elements, groupKey) {\n    this._manager && this._insert(elements, APPEND, groupKey);\n    return this;\n  }\n  /**\n   * Adds a card element at the top of a layout. This method is available only if the isProcessing() method returns false.\n   * @ko     . isProcessing()   'false'      \n   * @param {Array|jQuery} elements Array of the card elements to be added <ko>   </ko>\n   * @param {Number|String} [groupKey] The group key to be configured in a card element. It is automatically generated by default.\n   * <ko>     .    .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.prepend(\"&lt;div class='item'&gt;test1&lt;/div&gt;&lt;div class='item'&gt;test2&lt;/div&gt;\");\n   * infinitegrid.prepend([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]);\n   * infinitegrid.prepend([HTMLElement1, HTMLElement2]);\n   * infinitegrid.prepend(jQuery([\"&lt;div class='item'&gt;test1&lt;/div&gt;\", \"&lt;div class='item'&gt;test2&lt;/div&gt;\"]));\n   */\n\n\n  prepend(elements, groupKey) {\n    this._manager && this._insert(elements, PREPEND, groupKey);\n    return this;\n  }\n  /**\n   * Specifies the Layout class to use.\n   * @ko  Layout  .\n   * @param {Class|Object} LayoutKlass The Layout class to use or an instance of a layout moudle<ko> Layout     </ko>\n   * @param {Object} options Options to apply to the Layout.<ko>Layout  </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   * @example\n   * infinitegrid.setLayout(eg.InfiniteGrid.GridLayout, {\n   *  margin: 10,\n   *  align: \"start\"\n   * });\n    * infinitegrid.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n   *  margin: 10,\n   *  minSize: 100,\n   *  maxSize: 200\n   * });\n    * infinitegrid.setLayout(eg.InfiniteGrid.SquareLayout, {\n   *  margin: 10,\n   *  column: 2\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.FrameLayout, {\n   *  margin: 10,\n   *  frame: [\n   *   [1, 2],\n    *   [4, 3],\n   *  ]\n   * });\n   * infinitegrid.setLayout(eg.InfiniteGrid.PackingLayout, {\n   *  margin: 10,\n   *  aspectRatio: 1.5\n   * });\n   * var layout = new eg.InfiniteGrid.GridLayout({\n   * \tmargin: 10,\n   *\talign: \"start\"\n   * });\n   * infinitegrid.setLayout(layout);\n   */\n\n\n  setLayout(LayoutKlass, options = {}) {\n    const {\n      isEqualSize,\n      isConstantSize,\n      attributePrefix,\n      horizontal\n    } = this.options;\n\n    if (!this._manager) {\n      this._manager = new LayoutMananger(this._items, this._renderer, {\n        attributePrefix,\n        isEqualSize,\n        isConstantSize\n      });\n    }\n\n    if (typeof LayoutKlass === \"function\") {\n      this._manager.setLayout(new LayoutKlass(Object.assign(options, {\n        horizontal\n      })));\n    } else {\n      LayoutKlass.options.horizontal = horizontal;\n\n      this._manager.setLayout(LayoutKlass);\n    }\n\n    this._renderer.resize();\n\n    this._setSize(this._renderer.getViewportSize());\n\n    return this;\n  }\n\n  _setSize(size) {\n    this._infinite.setSize(this._renderer.getViewSize());\n\n    this._manager.setSize(size);\n  }\n  /**\n   * Returns the layouted items.\n   * @ko   .\n   * @param {Boolean} includeCached Indicates whether to include the cached items. <ko>    .</ko>\n   * @returns {Array} List of items <ko> </ko>\n   */\n\n\n  getItems(includeCached = false) {\n    return includeCached ? this._items.pluck(\"items\") : this._infinite.getVisibleItems();\n  }\n\n  _fitItems(base, margin = 0) {\n    base > 0 && this._watcher.scrollBy(-base);\n\n    this._items.fit(base, this.options.horizontal);\n\n    DOMRenderer.renderItems(this.getItems());\n\n    this._setContainerSize(this._getEdgeValue(\"end\") || margin);\n\n    base < 0 && this._watcher.scrollBy(-base);\n  } // called by visible\n\n\n  _fit(useFit = this.options.useFit) {\n    let base = this._getEdgeValue(\"start\");\n\n    const margin = this._getLoadingStatus() === LOADING_PREPEND && this._status.loadingSize || 0;\n    const {\n      isConstantSize,\n      isEqualSize,\n      useRecycle\n    } = this.options;\n\n    if (!useRecycle || !useFit || isConstantSize || isEqualSize) {\n      if (base < margin) {\n        this._fitItems(base - margin, margin);\n      }\n\n      base = 0;\n    } else if (base !== 0 || margin) {\n      this._fitItems(base - margin, margin);\n    } else {\n      return 0;\n    }\n\n    this._isLoading() && this._renderLoading();\n    return base;\n  }\n\n  _getEdgeValue(cursor) {\n    return this._infinite.getEdgeValue(cursor);\n  }\n  /**\n   * Rearranges a layout.\n   * @ko   .\n   * @param {Boolean} [isRelayout=true] Indicates whether a card element is being relayouted <ko>   </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  layout(isRelayout = true) {\n    if (!this._manager) {\n      return this;\n    }\n\n    const renderer = this._renderer;\n    const itemManager = this._items;\n    const infinite = this._infinite;\n    const isResize = renderer.resize();\n    const items = this.getItems();\n    const {\n      isEqualSize,\n      isConstantSize,\n      transitionDuration\n    } = this.options;\n    const isLayoutAll = isRelayout && (isEqualSize || isConstantSize);\n    const size = itemManager.size();\n\n    if (isRelayout && isResize) {\n      this._setSize(renderer.getViewportSize());\n    } // check childElement\n\n\n    if (!size) {\n      this._insert(toArray(renderer.container.children), true);\n\n      return this;\n    }\n\n    if (!items.length) {\n      return this;\n    } // layout datas\n\n\n    const startCursor = infinite.getCursor(\"start\");\n    const endCursor = infinite.getCursor(\"end\");\n    const data = isLayoutAll || !(isRelayout && isResize) ? itemManager.get() : itemManager.get(startCursor, endCursor); // LayoutManger interface\n\n    this._manager.layout(isRelayout, data, isResize ? items : []);\n\n    if (isLayoutAll) {\n      this._fit();\n    } else if (isRelayout && isResize) {\n      itemManager.clearOutlines(startCursor, endCursor);\n    }\n\n    DOMRenderer.renderItems(items, transitionDuration);\n    isRelayout && this._watcher.setScrollPos();\n\n    this._onLayoutComplete({\n      items,\n      isAppend: APPEND,\n      fromCache: CACHE,\n      isTrusted: NO_TRUSTED,\n      useRecycle: false,\n      isLayout: true\n    });\n\n    return this;\n  }\n  /**\n   * Removes a item element on a grid layout.\n   * @ko     .\n   * @param {HTMLElement} item element to be removed <ko>  </ko>\n   * @return {Object}  Removed item element <ko>   </ko>\n   */\n\n\n  remove(element, isLayout = true) {\n    if (element) {\n      const items = this._infinite.remove(element);\n\n      items && DOMRenderer.removeElement(element);\n      isLayout && this.layout(false);\n      return items;\n    }\n\n    return null;\n  }\n  /**\n   * Returns the list of group keys which belongs to card elements currently being maintained. You can use the append() or prepend() method to configure group keys so that multiple card elements can be managed at once. If you do not use these methods to configure group keys, groupkey is automatically generated.\n   * @ko         .         append()  prepend()      . append()  prepend()        .\n   * @param {Boolean} includeCached Indicates whether to include the cached groups. <ko>    .</ko>\n   * @return {Array} List of group keys <ko>  </ko>\n   */\n\n\n  getGroupKeys(includeCached) {\n    const data = includeCached ? this._items.get() : this._infinite.getVisibleData();\n    return data.map(v => v.groupKey);\n  }\n  /**\n   * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n   * @ko         .       setStatus()    \n   * @return {Object} State object of the eg.InfiniteGrid module<ko>eg.InfiniteGrid   </ko>\n   */\n\n\n  getStatus(startKey, endKey) {\n    return {\n      _status: Object.assign({}, this._status),\n      _items: this._items.getStatus(startKey, endKey),\n      _renderer: this._renderer.getStatus(),\n      _watcher: this._watcher.getStatus(),\n      _infinite: this._infinite.getStatus(startKey, endKey)\n    };\n  }\n  /**\n   * Sets the state of the eg.InfiniteGrid module with the information returned through a call to the getStatue() method.\n   * @ko getStatue()    eg.InfiniteGrid   .\n   * @param {Object} status State object of the eg.InfiniteGrid module <ko>eg.InfiniteGrid   </ko>\n   * @param {boolean} [applyScrollPos=true] Checks whether to scroll<ko>   .</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  setStatus(status, applyScrollPos = true) {\n    if (!status) {\n      return this;\n    }\n\n    const {\n      _status,\n      _renderer,\n      _items,\n      _watcher,\n      _infinite\n    } = status;\n\n    if (!_status || !_renderer || !_items || !_watcher || !_infinite) {\n      return this;\n    }\n\n    const items = this._items;\n    const renderer = this._renderer;\n    const watcher = this._watcher;\n    const infinite = this._infinite;\n    watcher.detachEvent();\n    Object.assign(this._status, _status);\n    this._status.processingStatus = IDLE;\n    items.setStatus(_items);\n    renderer.setStatus(_renderer);\n    infinite.setStatus(_infinite);\n    const visibleItems = this.getItems();\n    const length = visibleItems.length;\n    renderer.createAndInsert(visibleItems);\n    const isReLayout = renderer.isNeededResize();\n    watcher.setStatus(_watcher, applyScrollPos);\n    watcher.attachEvent();\n    const {\n      isConstantSize,\n      isEqualSize\n    } = this.options;\n\n    if (!length) {\n      this._requestAppend({\n        cache: visibleItems.slice(0, 1)\n      });\n    } else if (isReLayout) {\n      renderer.resize();\n\n      this._setSize(renderer.getViewportSize());\n\n      if (isConstantSize) {\n        this.layout(true);\n      } else {\n        this._items.clearOutlines();\n\n        this._postLayout({\n          fromCache: true,\n          groups: isEqualSize ? items.get() : infinite.getVisibleData(),\n          items: visibleItems,\n          newItems: visibleItems,\n          isAppend: true,\n          isTrusted: false\n        });\n      }\n    } else {\n      this.layout(false);\n    }\n\n    return this;\n  }\n  /**\n   * Clears added card elements and data.\n   * @ko      .\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  clear() {\n    this._items.clear();\n\n    this._renderer.clear();\n\n    this._infinite.clear();\n\n    this._reset();\n\n    this._appendLoadingBar();\n\n    return this;\n  }\n  /**\n   * Specifies the Loading Bar to use for append or prepend items.\n   * @ko  append  prepend      .\n   * @param {String|Object} [userLoadingBar={}] The loading bar HTML markup or element or element selector <ko>   HTML  element  selector </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  setLoadingBar(userLoadingBar = {}) {\n    const loadingBarObj = typeof userLoadingBar === \"object\" ? userLoadingBar : {\n      \"append\": userLoadingBar,\n      \"prepend\": userLoadingBar\n    };\n    this._status.loadingSize = 0;\n    this._status.loadingStyle = {};\n    const loadingBar = this._loadingBar;\n\n    for (const type in loadingBarObj) {\n      loadingBar[type] = $(loadingBarObj[type]);\n      loadingBar[type].className += ` ${IGNORE_CLASSNAME}`;\n    }\n\n    this._appendLoadingBar();\n\n    return this;\n  }\n\n  _appendLoadingBar() {\n    const loadingBar = this._loadingBar;\n    const container = this._renderer.container;\n\n    for (const type in loadingBar) {\n      container.appendChild(loadingBar[type]);\n    }\n  }\n  /**\n   * Checks whether a card element or data is being added.\n   * @ko         \n   * @return {Boolean} Indicates whether a card element or data is being added <ko>        </ko>\n   */\n\n\n  isProcessing() {\n    return this._isProcessing() || this._isLoading();\n  }\n\n  _isProcessing() {\n    return (this._status.processingStatus & PROCESSING) > 0;\n  }\n\n  _isLoading() {\n    return this._getLoadingStatus() > 0;\n  }\n\n  _getLoadingStatus() {\n    return this._status.processingStatus & (LOADING_APPEND | LOADING_PREPEND);\n  }\n\n  _process(status, isAdd = true) {\n    if (isAdd) {\n      this._status.processingStatus |= status;\n    } else {\n      this._status.processingStatus -= this._status.processingStatus & status;\n    }\n  }\n\n  _insert(elements, isAppend, groupKey) {\n    if (this._isProcessing() || elements.length === 0) {\n      return;\n    }\n\n    const key = typeof groupKey === \"undefined\" ? new Date().getTime() + Math.floor(Math.random() * 1000) : groupKey;\n    const items = ItemManager.from(elements, this.options.itemSelector, {\n      isAppend,\n      groupKey: key,\n      outlines: {\n        start: [],\n        end: []\n      }\n    });\n\n    if (!items.length) {\n      return;\n    }\n\n    const group = {\n      groupKey: key,\n      items,\n      outlines: {\n        start: [],\n        end: []\n      }\n    };\n    const method = isAppend ? \"append\" : \"prepend\";\n\n    this._items[method](group);\n\n    if (!isAppend) {\n      const infinite = this._infinite;\n      const startCursor = infinite.getCursor(\"start\");\n      const endCursor = infinite.getCursor(\"end\");\n      infinite.setCursor(\"start\", startCursor + 1);\n      infinite.setCursor(\"end\", endCursor + 1);\n    }\n\n    this._postLayout({\n      fromCache: NO_CACHE,\n      groups: [group],\n      items,\n      newItems: items,\n      isAppend,\n      isTrusted: NO_TRUSTED\n    });\n  } // add items, and remove items for recycling\n\n\n  _recycle({\n    start,\n    end\n  }) {\n    if (!this.options.useRecycle) {\n      return;\n    }\n\n    DOMRenderer.removeItems(this._items.pluck(\"items\", start, end));\n  }\n  /**\n   * Returns the element of loading bar.\n   * @ko   element .\n   * @param {Boolean} [isAppend=currentLoadingBar|true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n   * @return {Element} The element of loading bar. <ko>  element</ko>\n   */\n\n\n  getLoadingBar(isAppend = this._getLoadingStatus() !== LOADING_PREPEND) {\n    return this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n  }\n  /**\n   * Start loading for append/prepend during loading data.\n   * @ko    append/prepend   .\n   * @param {Boolean} [isAppend=true] Checks whether the card element is added to the append () method. <ko>  append()     .</ko>\n   * @param {Object} [userStyle = {display: \"block\"}] custom style to apply to this loading bar for start. <ko>         </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  startLoading(isAppend, userStyle = {\n    display: \"block\"\n  }) {\n    if (this._isLoading()) {\n      return this;\n    }\n\n    const type = isAppend ? \"append\" : \"prepend\";\n\n    this._process(isAppend ? LOADING_APPEND : LOADING_PREPEND);\n\n    if (!this._loadingBar[type]) {\n      return this;\n    }\n\n    this._renderLoading(userStyle);\n\n    this._status.loadingStyle = userStyle;\n\n    if (!isAppend) {\n      this._fit();\n    } else {\n      this._setContainerSize(this._getEdgeValue(\"end\") + this._status.loadingSize);\n    }\n\n    return this;\n  }\n\n  _renderLoading(userStyle = this._status.loadingStyle) {\n    if (!this._isLoading()) {\n      return;\n    }\n\n    const isAppend = this._getLoadingStatus() === LOADING_APPEND;\n    const el = this._loadingBar[isAppend ? \"append\" : \"prepend\"];\n\n    if (!el) {\n      return;\n    }\n\n    const style = Object.assign({\n      position: \"absolute\"\n    }, userStyle);\n\n    for (const property in style) {\n      el.style[property] = style[property];\n    }\n\n    this._status.loadingSize = this.options.horizontal ? outerWidth(el) : outerHeight(el);\n    const posName = this.options.horizontal ? \"left\" : \"top\";\n\n    if (!(posName in style)) {\n      const pos = isAppend ? this._getEdgeValue(\"end\") : this._getEdgeValue(\"start\") - this._status.loadingSize;\n      el.style[posName] = `${pos}px`;\n    }\n  }\n  /**\n   * End loading after startLoading() for append/prepend\n   * @ko  append/prepend  startLoading()    .\n   * @param {Object} [userStyle = {display: \"none\"}] custom style to apply to this loading bar for end <ko>         </ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  endLoading(userStyle = {\n    display: \"none\"\n  }) {\n    if (!this._isLoading()) {\n      return this;\n    }\n\n    const isAppend = this._getLoadingStatus() === LOADING_APPEND;\n    const type = isAppend ? \"append\" : \"prepend\";\n    const el = this._loadingBar[type];\n    const status = this._status;\n    const size = status.loadingSize;\n\n    this._process(LOADING_APPEND | LOADING_PREPEND, false);\n\n    status.loadingSize = 0;\n    status.loadingStyle = {};\n\n    if (el) {\n      const style = Object.assign({\n        [this.options.horizontal ? \"left\" : \"top\"]: `${-size}px`\n      }, userStyle);\n\n      for (const property in style) {\n        el.style[property] = style[property];\n      }\n\n      if (!isAppend) {\n        this._fitItems(size);\n      } else {\n        this._setContainerSize(this._getEdgeValue(\"end\"));\n      }\n    }\n\n    if (this.options.useRecycle && !this.isProcessing()) {\n      this._infinite.recycle(this._watcher.getScrollPos(), isAppend);\n    }\n\n    return this;\n  }\n\n  _setContainerSize(size) {\n    this._renderer.setContainerSize(Math.max(this._items.getMaxEdgeValue(), size));\n  }\n  /**\n   * Move to some group or item position.\n   * @ko      .\n   * @param {Number} [index] group's index <ko>  index</ko>\n   * @param {Number} [itemIndex=-1] item's index <ko>  index</ko>\n   * @return {eg.InfiniteGrid} An instance of a module itself<ko>  </ko>\n   */\n\n\n  moveTo(index, itemIndex = 0) {\n    if (this.isProcessing()) {\n      return this;\n    }\n\n    const data = this._items.getData(index);\n\n    if (!data) {\n      return this;\n    }\n\n    const infinite = this._infinite;\n    const outlines = data.outlines;\n    const items = data.items;\n    const item = items[itemIndex];\n    const isResize = outlines.start && outlines.start.length === 0;\n    const startCursor = infinite.getCursor(\"start\");\n    const endCursor = infinite.getCursor(\"end\");\n    const isInCursor = startCursor <= index && index <= endCursor;\n    const {\n      useRecycle,\n      horizontal\n    } = this.options;\n\n    if (isInCursor || !useRecycle || !isResize) {\n      let pos = item ? item.rect[horizontal ? \"left\" : \"top\"] : Math.max(...outlines.start);\n      const fit = Math.min(...outlines.start);\n\n      if (fit < 0) {\n        // base < 0\n        this._fitItems(fit, 0);\n\n        pos -= fit;\n      }\n\n      const isAppend = index > startCursor;\n\n      if (isInCursor || isAppend) {\n        this._scrollTo(pos);\n\n        return this;\n      }\n\n      this._postLayout({\n        fromCache: true,\n        groups: [data],\n        items,\n        newItems: [],\n        isAppend,\n        isTrusted: false,\n        moveCache: true,\n        moveItem: itemIndex\n      });\n\n      return this;\n    } else {\n      const isAppend = index > endCursor || index < startCursor - 1;\n\n      this._postCache({\n        isAppend,\n        cache: [data],\n        isTrusted: false,\n        moveItem: itemIndex\n      });\n    }\n\n    return this;\n  }\n\n  _setScrollPos(pos) {\n    this._watcher.setScrollPos(this._watcher.getContainerOffset() + pos);\n  }\n\n  _scrollTo(pos) {\n    this._watcher.scrollTo(this._watcher.getContainerOffset() + pos);\n  }\n\n  _onImageError(e) {\n    /**\n     * This event is fired when an error occurs in the image.\n     * @ko       .\n     * @event eg.InfiniteGrid#imageError\n     * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n     * @param {Element} param.target Appending card's image element.<ko>    </ko>\n     * @param {Element} param.elememt The item's element with error images.<ko>     </ko>\n     * @param {Object} param.items The items being added.<ko>  </ko>\n     * @param {Object} param.item The item with error images.<ko>    </ko>\n     * @param {Number} param.itemIndex The item's index with error images.<ko>     </ko>\n     * @param {Function} param.remove In the imageError event, this method expects to remove the error image.<ko>       .</ko>\n     * @param {Function} param.removeItem In the imageError event, this method expects to remove the item with the error image.<ko>          .</ko>\n     * @param {Function} param.replace In the imageError event, this method expects to replace the error image's source or element.<ko>          .</ko>\n     * @param {Function} param.replaceItem In the imageError event, this method expects to replace the item's contents with the error image.<ko>           .</ko>\n     * @example\n    ig.on(\"imageError\", e => {\n    e.remove();\n    e.removeItem();\n    e.replace(\"http://...jpg\");\n    e.replace(imageElement);\n    e.replaceItem(\"item html\");\n    });\n     */\n    this.trigger(\"imageError\", Object.assign(e, {\n      element: e.item.el\n    }));\n  }\n\n  _postCache({\n    cache,\n    isAppend,\n    isTrusted = true,\n    moveItem = -1\n  }) {\n    const {\n      isConstantSize\n    } = this.options;\n    const items = ItemManager.pluck(cache, \"items\");\n    let fromCache = true;\n    const newItems = items.filter(item => {\n      if (!item.orgSize) {\n        fromCache = false;\n        return true;\n      }\n\n      return !isConstantSize && item.rect.top < DUMMY_POSITION / 10;\n    });\n\n    this._postLayout({\n      fromCache,\n      groups: cache,\n      items,\n      newItems,\n      isAppend,\n      isTrusted,\n      moveItem\n    });\n  }\n\n  _postLayout({\n    fromCache,\n    groups,\n    items = ItemManager.pluck(groups, \"items\"),\n    newItems,\n    isAppend,\n    isTrusted,\n    moveCache,\n    moveItem = -2\n  }) {\n    this._process(PROCESSING);\n\n    const method = isAppend ? \"append\" : \"prepend\";\n    const itemManager = this._items;\n    const horizontal = this.options.horizontal;\n    DOMRenderer.createElements(items);\n\n    this._renderer[method](items);\n\n    this._manager[method]({\n      groups,\n      items: newItems,\n      isAppend\n    }, {\n      complete: () => {\n        const infinite = this._infinite;\n        const startCursor = Math.max(infinite.getCursor(\"start\"), 0);\n        const endCursor = Math.max(infinite.getCursor(\"end\"), 0);\n        let requestStartCursor = itemManager.indexOf(groups[0].groupKey);\n        let requestEndCursor = itemManager.indexOf(groups[groups.length - 1].groupKey);\n        let isInCursor = true;\n\n        if (requestStartCursor > endCursor + 1 || requestEndCursor < startCursor - 1) {\n          isInCursor = false;\n        }\n\n        if (isInCursor) {\n          if (isAppend) {\n            requestStartCursor = startCursor;\n            requestEndCursor = Math.max(endCursor, requestEndCursor);\n          } else {\n            requestStartCursor = Math.max(Math.min(startCursor, requestStartCursor), 0);\n            requestEndCursor = endCursor;\n          }\n        }\n\n        !isInCursor && this._recycle({\n          start: startCursor,\n          end: endCursor\n        });\n        infinite.setCursor(\"start\", requestStartCursor);\n        infinite.setCursor(\"end\", requestEndCursor);\n\n        if (moveItem > -1) {\n          const pos = items[moveItem].rect[horizontal ? \"left\" : \"top\"];\n\n          if (!isInCursor && !moveCache) {\n            itemManager.clearOutlines(requestStartCursor, requestEndCursor);\n          }\n\n          this._scrollTo(pos);\n\n          this._setScrollPos(pos);\n        }\n\n        this._onLayoutComplete({\n          groups,\n          items,\n          isAppend,\n          fromCache,\n          isTrusted,\n          useRecycle: false\n        });\n      },\n      error: e => this._onImageError(e),\n      end: ({\n        remove,\n        layout\n      }) => {\n        remove.forEach(el => this.remove(el, false));\n\n        if (layout) {\n          this.layout(false);\n        } else if (!this.isProcessing() && this.options.useRecycle) {\n          const watcher = this._watcher;\n          const scrollPos = watcher.getScrollPos();\n\n          this._infinite.recycle(scrollPos, isAppend);\n        }\n      }\n    });\n\n    return this;\n  } // called by visible\n\n\n  _requestAppend({\n    cache\n  }) {\n    if (this._isProcessing()) {\n      return;\n    }\n\n    if (cache && cache.length) {\n      this._postCache({\n        cache,\n        isAppend: APPEND\n      });\n    } else {\n      /**\n       * This event is fired when a card element must be added at the bottom or right of a layout because there is no card to be displayed on screen when a user scrolls near bottom or right.\n       * @ko          .          \n       * @event eg.InfiniteGrid#append\n       * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n       * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n       * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n       * @param {Function} param.startLoading Start loading for append loading data. <ko>     . </ko>\n       * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n       * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       */\n      this.trigger(\"append\", {\n        isTrusted: TRUSTED,\n        groupKey: this.getGroupKeys().pop(),\n        startLoading: userStyle => {\n          this.startLoading(true, userStyle);\n        },\n        endLoading: userStyle => {\n          this.endLoading(userStyle);\n        }\n      });\n    }\n  } // called by visible\n\n\n  _requestPrepend({\n    cache\n  }) {\n    this._fit(this.options.useFit || !cache.length);\n\n    if (this._isProcessing()) {\n      return;\n    }\n\n    if (cache && cache.length) {\n      this._postCache({\n        cache,\n        isAppend: PREPEND\n      });\n    } else {\n      /**\n       * This event is fired when a card element must be added at the top or left of a layout because there is no card to be displayed on screen when a user scrolls near top or left.\n       * @ko         .          .\n       * @event eg.InfiniteGrid#prepend\n       * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n       * @param {String|Number} groupKey The group key of the first group visible on the screen <ko>    </ko>\n       * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n       * @param {Function} param.startLoading Start loading for prepend loading data. <ko>     . </ko>\n       * @param {Object} param.startLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n       * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n       */\n      this.trigger(\"prepend\", {\n        isTrusted: TRUSTED,\n        groupKey: this.getGroupKeys().shift(),\n        startLoading: userStyle => {\n          this.startLoading(false, userStyle);\n        },\n        endLoading: userStyle => {\n          this.endLoading(userStyle);\n        }\n      });\n    }\n  }\n\n  _onResize() {\n    this.layout(true);\n  }\n\n  _onCheck({\n    isForward,\n    scrollPos,\n    horizontal,\n    orgScrollPos\n  }) {\n    /**\n     * This event is fired when the user scrolls.\n     * @ko      .\n     * @event eg.InfiniteGrid#change\n     * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n     * @param {Boolean} param.isForward Indicates whether the scroll progression direction is forward or backword. <ko>    ,   .</ko>\n     * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n     * @param {Boolean} param.orgScrollPos Current position of the scroll <ko>  </ko>\n     * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n     * @param {Boolean} options.horizontal Direction of the scroll movement (true: horizontal, false: vertical) <ko>   (true , false </ko>\n     */\n    this.trigger(\"change\", {\n      isForward,\n      horizontal,\n      scrollPos,\n      orgScrollPos\n    });\n\n    this._infinite.scroll(scrollPos);\n  }\n\n  _onLayoutComplete({\n    items,\n    isAppend,\n    isTrusted = false,\n    useRecycle = this.options.useRecycle,\n    fromCache = false,\n    isLayout = false\n  }) {\n    const viewSize = this._renderer.getViewSize();\n\n    if (!isAppend) {\n      this._fit();\n    } else {\n      this._isLoading() && this._renderLoading();\n    }\n\n    const watcher = this._watcher;\n    const scrollPos = watcher.getScrollPos(); // recycle after _fit beacause prepend and append are occured simultaneously by scroll.\n\n    if (!isLayout && useRecycle && !this._isLoading()) {\n      this._infinite.recycle(scrollPos, isAppend);\n    }\n\n    const size = this._getEdgeValue(\"end\");\n\n    isAppend && this._setContainerSize(size + this._status.loadingSize || 0);\n    !isLayout && this._process(PROCESSING, false);\n    /**\n     * This event is fired when layout is successfully arranged through a call to the append(), prepend(), or layout() method.\n     * @ko      . append()  prepend() , layout()        \n     * @event eg.InfiniteGrid#layoutComplete\n     *\n     * @param {Object} param The object of data to be sent to an event <ko>   </ko>\n     * @param {Array} param.target Rearranged card elements<ko>  </ko>\n     * @param {Boolean} param.fromCache Check whether these items are cache or not <ko>    .</ko>\n     * @param {Boolean} param.isLayout Returns true if this is an event called by resize event or layout method. Returns false if this is an event called by adding an item. <ko>     layout()    true,    false .</ko>\n     * @param {Boolean} param.isAppend Checks whether the append() method is used to add a card element. It returns true even though the layoutComplete event is fired after the layout() method is called. <ko>  append()   . layout()    layoutComplete   'true' .</ko>\n     * @param {Boolean} param.isScroll Checks whether scrolling has occurred after the append(), prepend(), ..., etc method is called <ko>append, prend      .</ko>\n     * @param {Number} param.scrollPos Current scroll position value relative to the infiniteGrid container element. <ko>infiniteGrid      </ko>\n     * @param {Number} param.orgScrollPos Current position of the scroll <ko>  </ko>\n     * @param {Number} param.size The size of container element <ko>  </ko>\n     * @param {Boolean} param.isTrusted Returns true if an event was generated by the user action, or false if it was caused by a script or API call <ko>     true,  API    false .</ko>\n     * @param {Function} param.endLoading End loading after startLoading() for append/prepend loading data. <ko>   append/prepend startLoading()    .</ko>\n     * @param {Object} param.endLoading.userStyle The custom style to apply to this loading bar for start. <ko>         </ko>\n     */\n\n    this.trigger(\"layoutComplete\", {\n      target: items.concat(),\n      isAppend,\n      isTrusted,\n      fromCache,\n      isLayout,\n      isScroll: viewSize < watcher.getContainerOffset() + size,\n      scrollPos,\n      orgScrollPos: watcher.getOrgScrollPos(),\n      size,\n      endLoading: userStyle => {\n        this.endLoading(userStyle);\n      }\n    });\n\n    this._infinite.scroll(scrollPos, isAppend);\n  }\n\n  _reset() {\n    this._status = {\n      processingStatus: IDLE,\n      loadingSize: 0\n    };\n  }\n  /**\n   * Destroys elements, properties, and events used on a grid layout.\n   * @ko     ,  \n   */\n\n\n  destroy() {\n    this._infinite.clear();\n\n    this._watcher.destroy();\n\n    this._manager.destroy();\n\n    this._reset();\n\n    this._items.clear();\n\n    this._renderer.destroy();\n  }\n\n}\n\nexport default InfiniteGrid;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/InfiniteGrid.js\n// module id = null\n// module chunks = ","import { APPEND, PREPEND, ALIGN } from \"../consts\";\nimport { getStyleNames, assignOptions, fill, cloneItems } from \"../utils\"; // ALIGN\n\nconst {\n  START,\n  CENTER,\n  END,\n  JUSTIFY\n} = ALIGN;\n/**\n * @classdesc The GridLayout is a layout that stacks cards with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new card.\n * @ko GridLayout          .      ,        .            .\n * @class eg.InfiniteGrid.GridLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.GridLayout module <ko>eg.InfiniteGrid.GridLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.align=START] Align of the position of the items (START, CENTER, END, JUSTIFY) <ko>   (START, CENTER, END, JUSTIFY)</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.GridLayout, {\n\tmargin: 10,\n\talign: \"start\",\n\titemSize: 200\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.GridLayout({\n\tmargin: 10,\n\talign: \"center\",\n\titemSize: 200,\n\thorizontal: true,\n});\n\n</script>\n```\n **/\n\nclass GridLayout {\n  constructor(options = {}) {\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      align: START,\n      itemSize: 0\n    }, options);\n    this._size = 0;\n    this._columnSize = 0;\n    this._columnLength = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n\n  checkColumn(item) {\n    const {\n      itemSize,\n      margin,\n      horizontal\n    } = this.options;\n    const sizeName = horizontal ? \"height\" : \"width\";\n    const columnSize = parseInt(itemSize || item && item.size[sizeName], 10) || 0;\n    this._columnSize = columnSize;\n\n    if (!columnSize) {\n      this._columnLength = 1;\n      return;\n    }\n\n    this._columnLength = Math.max(parseInt((this._size + margin) / (columnSize + margin), 10), 1);\n  }\n\n  _layout(items, outline, isAppend) {\n    const length = items.length;\n    const margin = this.options.margin;\n    const align = this.options.align;\n    const style = this._style;\n    const size1Name = style.size1;\n    const size2Name = style.size2;\n    const pos1Name = style.pos1;\n    const pos2Name = style.pos2;\n    const columnSize = this._columnSize;\n    const columnLength = this._columnLength;\n    const size = this._size;\n    const viewDist = size - (columnSize + margin) * columnLength + margin;\n    const pointCaculateName = isAppend ? \"min\" : \"max\";\n    const startOutline = outline.slice();\n    const endOutline = outline.slice();\n\n    for (let i = 0; i < length; ++i) {\n      const point = Math[pointCaculateName](...endOutline) || 0;\n      let index = endOutline.indexOf(point);\n      const item = items[isAppend ? i : length - 1 - i];\n      const size1 = item.size[size1Name];\n      const size2 = item.size[size2Name];\n      const pos1 = isAppend ? point : point - margin - size1;\n      const endPos1 = pos1 + size1 + margin;\n\n      if (index === -1) {\n        index = 0;\n      }\n\n      let pos2 = (columnSize + margin) * index; // ALIGN\n\n      if (align === CENTER) {\n        pos2 += viewDist / 2;\n      } else if (align === END) {\n        pos2 += viewDist + columnSize - size2;\n      } else if (align === JUSTIFY) {\n        if (columnLength <= 1) {\n          pos2 += viewDist / 2;\n        } else {\n          pos2 = (size - columnSize) / (columnLength - 1) * index;\n        }\n      } // tetris\n\n\n      item.rect = {\n        [pos1Name]: pos1,\n        [pos2Name]: pos2\n      };\n      item.column = index;\n      endOutline[index] = isAppend ? endPos1 : pos1;\n    }\n\n    if (!isAppend) {\n      items.sort((a, b) => {\n        const item1pos1 = a.rect[pos1Name];\n        const item1pos2 = a.rect[pos2Name];\n        const item2pos1 = b.rect[pos1Name];\n        const item2pos2 = b.rect[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n    } // if append items, startOutline is low, endOutline is high\n    // if prepend items, startOutline is high, endOutline is low\n\n\n    return {\n      start: isAppend ? startOutline : endOutline,\n      end: isAppend ? endOutline : startOutline\n    };\n  }\n\n  _insert(items = [], outline = [], type, cache) {\n    const clone = cache ? items : cloneItems(items);\n    let startOutline = outline;\n\n    if (!this._columnLength) {\n      this.checkColumn(items[0]);\n    }\n\n    if (outline.length !== this._columnLength) {\n      startOutline = fill(new Array(this._columnLength), outline.length === 0 ? 0 : Math[type === APPEND ? \"min\" : \"max\"](...outline) || 0);\n    }\n\n    const result = this._layout(clone, startOutline, type);\n\n    return {\n      items: clone,\n      outlines: result\n    };\n  }\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100, 200, 300, 400]);\n   */\n\n\n  append(items, outline, cache) {\n    return this._insert(items, outline, APPEND, cache);\n  }\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100, 200, 300, 400]);\n   */\n\n\n  prepend(items, outline, cache) {\n    return this._insert(items, outline, PREPEND, cache);\n  }\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.GridLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  layout(groups = [], outline = []) {\n    const firstItem = groups.length && groups[0].items.length && groups[0].items[0] || 0;\n    this.checkColumn(firstItem); // if outlines' length and columns' length are now same, re-caculate outlines.\n\n    let startOutline;\n\n    if (outline.length !== this._columnLength) {\n      const pos = outline.length === 0 ? 0 : Math.min(...outline); // re-layout items.\n\n      startOutline = fill(new Array(this._columnLength), pos);\n    } else {\n      startOutline = outline.slice();\n    }\n\n    groups.forEach(group => {\n      const items = group.items;\n\n      const result = this._layout(items, startOutline, APPEND);\n\n      group.outlines = result;\n      startOutline = result.end;\n    });\n    return this;\n  }\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.GridLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.GridLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  setSize(size) {\n    this._size = size;\n    return this;\n  }\n\n}\n\nexport default GridLayout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/GridLayout.js\n// module id = null\n// module chunks = ","import { APPEND, PREPEND, DUMMY_POSITION } from \"../consts\";\nimport { getStyleNames, assignOptions, fill, cloneItems } from \"../utils\";\n/*\nFrame\n[\n[1, 1, 1, 1, 1],\n[0, 0, 2, 2, 2],\n[0, 0, 2, 2, 2],\n[3, 4, 5, 5, 5],\n]\n*/\n\nfunction disableFrame(frame, type, x, y, width, height) {\n  for (let i = y; i < y + height; ++i) {\n    for (let j = x; j < x + width; ++j) {\n      if (type !== frame[i][j]) {\n        continue;\n      }\n\n      frame[i][j] = 0;\n    }\n  }\n}\n\nfunction searchShapeInFrame(frame, type, top, left, width, height) {\n  const size = {\n    left,\n    top,\n    type,\n    width: 1,\n    height: 1\n  };\n\n  for (let i = left; i < width; ++i) {\n    if (frame[top][i] === type) {\n      size.width = i - left + 1;\n      continue;\n    }\n\n    break;\n  }\n\n  for (let i = top; i < height; ++i) {\n    if (frame[i][left] === type) {\n      size.height = i - top + 1;\n      continue;\n    }\n\n    break;\n  } // After finding the shape, it will not find again.\n\n\n  disableFrame(frame, type, left, top, size.width, size.height);\n  return size;\n}\n\nfunction getShapes(frame) {\n  const height = frame.length;\n  const width = height ? frame[0].length : 0;\n  const shapes = [];\n\n  for (let i = 0; i < height; ++i) {\n    for (let j = 0; j < width; ++j) {\n      const type = frame[i][j];\n\n      if (!type) {\n        continue;\n      } // Separate shapes with other numbers.\n\n\n      shapes.push(searchShapeInFrame(frame, type, i, j, width, height));\n    }\n  }\n\n  shapes.sort((a, b) => a.type < b.type ? -1 : 1);\n  return {\n    shapes,\n    width,\n    height\n  };\n}\n/**\n * @classdesc FrameLayout is a layout that allows you to place cards in a given frame. It is a layout that corresponds to a level intermediate between the placement of the image directly by the designer and the layout using the algorithm.\n * @ko FrameLayout      .             .\n * @class eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.FrameLayout module <ko>eg.InfiniteGrid.FrameLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frame=[]] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @param {Boolean} [options.frameFill=true] Make sure that the frame can be attached after the previous frame. <ko>          . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.FrameLayout, {\n\tmargin: 10,\n\titemSize: 200,\n\tframe: [\n\t\t[1, 1, 1, 1, 1],\n\t\t[0, 0, 2, 2, 2],\n\t\t[0, 0, 2, 2, 2],\n\t\t[3, 4, 5, 5, 5],\n\t],\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.FrameLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n\tframe: [\n\t\t[1, 1, 1, 1, 1],\n\t\t[0, 0, 2, 2, 2],\n\t\t[0, 0, 2, 2, 2],\n\t\t[3, 4, 5, 5, 5],\n\t],\n});\n\n</script>\n```\n **/\n\n\nclass FrameLayout {\n  constructor(options = {}) {\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      itemSize: 0,\n      frame: [],\n      frameFill: true\n    }, options);\n    const frame = this.options.frame.map(row => row.slice());\n    this._itemSize = this.options.itemSize || 0; // divide frame into shapes.\n\n    this._shapes = getShapes(frame);\n    this._size = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n\n  _getItemSize() {\n    this._checkItemSize();\n\n    return this._itemSize;\n  }\n\n  _checkItemSize() {\n    if (this.options.itemSize) {\n      this._itemSize = this.options.itemSize;\n      return;\n    }\n\n    const style = this._style;\n    const size = style.size2;\n    const margin = this.options.margin; // if itemSize is not in options, caculate itemSize from size.\n\n    this._itemSize = (this._size + margin) / this._shapes[size] - margin;\n  }\n\n  _layout(items, outline = [], isAppend) {\n    const length = items.length;\n    const style = this._style;\n    const {\n      margin,\n      frameFill\n    } = this.options;\n    const size1Name = style.size1;\n    const size2Name = style.size2;\n    const pos1Name = style.pos1;\n    const pos2Name = style.pos2;\n\n    const itemSize = this._getItemSize();\n\n    const isItemObject = typeof itemSize === \"object\";\n    const itemSize2 = isItemObject ? itemSize[size2Name] : itemSize;\n    const itemSize1 = isItemObject ? itemSize[size1Name] : itemSize;\n    const shapesSize = this._shapes[size2Name];\n    const shapes = this._shapes.shapes;\n    const shapesLength = shapes.length;\n    const startOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n    const endOutline = fill(new Array(shapesSize), DUMMY_POSITION);\n    let dist = 0;\n    let end = 0;\n\n    if (!shapesLength) {\n      return {\n        start: outline,\n        end: outline\n      };\n    }\n\n    for (let i = 0; i < length; i += shapesLength) {\n      for (let j = 0; j < shapesLength && i + j < length; ++j) {\n        const item = items[i + j];\n        const shape = shapes[j];\n        const shapePos1 = shape[pos1Name];\n        const shapePos2 = shape[pos2Name];\n        const shapeSize1 = shape[size1Name];\n        const shapeSize2 = shape[size2Name];\n        const pos1 = end - dist + shapePos1 * (itemSize1 + margin);\n        const pos2 = shapePos2 * (itemSize2 + margin);\n        const size1 = shapeSize1 * (itemSize1 + margin) - margin;\n        const size2 = shapeSize2 * (itemSize2 + margin) - margin;\n\n        for (let k = shapePos2; k < shapePos2 + shapeSize2 && k < shapesSize; ++k) {\n          if (startOutline[k] === DUMMY_POSITION) {\n            startOutline[k] = pos1;\n          }\n\n          startOutline[k] = Math.min(startOutline[k], pos1);\n          endOutline[k] = Math.max(endOutline[k], pos1 + size1 + margin);\n        }\n\n        item.rect = {\n          [pos1Name]: pos1,\n          [pos2Name]: pos2,\n          [size1Name]: size1,\n          [size2Name]: size2\n        };\n      }\n\n      end = Math.max(...endOutline); // check dist once\n\n      if (i !== 0) {\n        continue;\n      } // find & fill empty block\n\n\n      if (!frameFill) {\n        dist = 0;\n        continue;\n      }\n\n      dist = end;\n\n      for (let j = 0; j < shapesSize; ++j) {\n        if (startOutline[j] === DUMMY_POSITION) {\n          continue;\n        } // the dist between frame's end outline and next frame's start outline\n        // expect that next frame's start outline is startOutline[j] + end\n\n\n        dist = Math.min(startOutline[j] + end - endOutline[j], dist);\n      }\n    }\n\n    for (let i = 0; i < shapesSize; ++i) {\n      if (startOutline[i] !== DUMMY_POSITION) {\n        continue;\n      }\n\n      startOutline[i] = Math.max(...startOutline);\n      endOutline[i] = startOutline[i];\n    } // The target outline is start outline when type is APPENDING\n\n\n    const targetOutline = isAppend ? startOutline : endOutline;\n    const prevOutlineEnd = outline.length === 0 ? 0 : Math[isAppend ? \"max\" : \"min\"](...outline);\n    let prevOutlineDist = isAppend ? 0 : end;\n\n    if (frameFill && outline.length === shapesSize) {\n      prevOutlineDist = -DUMMY_POSITION;\n\n      for (let i = 0; i < shapesSize; ++i) {\n        if (startOutline[i] === endOutline[i]) {\n          continue;\n        } // if appending type is PREPEND, subtract dist from appending group's height.\n\n\n        prevOutlineDist = Math.min(targetOutline[i] + prevOutlineEnd - outline[i], prevOutlineDist);\n      }\n    }\n\n    for (let i = 0; i < shapesSize; ++i) {\n      startOutline[i] += prevOutlineEnd - prevOutlineDist;\n      endOutline[i] += prevOutlineEnd - prevOutlineDist;\n    }\n\n    items.forEach(item => {\n      item.rect[pos1Name] += prevOutlineEnd - prevOutlineDist;\n    });\n    return {\n      start: startOutline.map(point => parseInt(point, 10)),\n      end: endOutline.map(point => parseInt(point, 10))\n    };\n  }\n\n  _insert(items = [], outline = [], type, cache) {\n    // this only needs the size of the item.\n    const clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, type)\n    };\n  }\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.FrameLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  layout(groups = [], outline = []) {\n    const length = groups.length;\n    let point = outline;\n\n    for (let i = 0; i < length; ++i) {\n      const group = groups[i];\n      point = this._layout(group.items, point, APPEND);\n      group.outlines = point;\n      point = point.end;\n    }\n\n    return this;\n  }\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.FrameLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  setSize(size) {\n    this._size = size;\n    return this;\n  }\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  append(items, outline, cache) {\n    return this._insert(items, outline, APPEND, cache);\n  }\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.FrameLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  prepend(items, outline, cache) {\n    return this._insert(items, outline, PREPEND, cache);\n  }\n\n}\n\nexport default FrameLayout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/FrameLayout.js\n// module id = null\n// module chunks = ","import FrameLayout from \"./FrameLayout\";\nimport { fill } from \"../utils\";\n\nfunction makeShapeOutline(outline, itemSize, columnLength, isAppend) {\n  const point = Math[isAppend ? \"min\" : \"max\"](...outline) || 0;\n\n  if (outline.length !== columnLength) {\n    return fill(new Array(columnLength), 0);\n  }\n\n  return outline.map(l => parseInt((l - point) / itemSize, 10));\n}\n\nfunction getColumn(item) {\n  if (item.column) {\n    return item.column;\n  }\n\n  let column = 0;\n\n  if (item.el) {\n    const dataset = item.el.dataset;\n\n    if (dataset) {\n      column = dataset.column || 1;\n    } else {\n      column = item.el.getAttribute(\"column\") || 1;\n    }\n  } else {\n    column = 1;\n  }\n\n  item.column = column;\n  return column;\n}\n/**\n * @classdesc SquareLayout is a layout that places all cards like squares on a checkerboard, and important cards are n times larger. The main card can be enlarged, and then a small card can be placed to naturally show the relationship of the card.\n * @ko SquareLayout         N   .    ,           .\n * @class eg.InfiniteGrid.SquareLayout\n * @extends eg.InfiniteGrid.FrameLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.SquareLayout module <ko>eg.InfiniteGrid.SquareLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.itemSize=0] The size of the items. If it is 0, it is calculated as the size of the first item in items. <ko>  .    0,      . </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.SquareLayout, {\n\tmargin: 10,\n\titemSize: 200,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.SquareLayout({\n\tmargin: 10,\n\titemSize: 200,\n\thorizontal: true,\n});\n\n\nvar item1 = '<div data-column=\"2\"></div>';\nvar item2 = \"<div></div>\"\nlayout.append([item1, item2]);\n</script>\n```\n **/\n\n\nclass SquareLayout extends FrameLayout {\n  _checkItemSize() {\n    const column = this.options.column;\n\n    if (!column) {\n      super._checkItemSize();\n\n      return;\n    }\n\n    const margin = this.options.margin; // if itemSize is not in options, caculate itemSize from size.\n\n    this._itemSize = (this._size + margin) / column - margin;\n  }\n\n  _layout(items, outline = [], isAppend) {\n    const itemSize = this._getItemSize();\n\n    const margin = this.options.margin;\n    const columnLength = this.options.column || parseInt((this._size + margin) / (itemSize + margin), 10) || 1;\n    const length = items.length;\n    const endOutline = makeShapeOutline(outline, itemSize, columnLength, isAppend);\n    const pointCaculateName = isAppend ? \"min\" : \"max\";\n    const shapes = [];\n    const sign = isAppend ? 1 : -1;\n    const style = this._style;\n    const pos1Name = style.pos1;\n    const pos2Name = style.pos2;\n\n    for (let i = 0; i < length; ++i) {\n      const point = Math[pointCaculateName](...endOutline);\n      let index = endOutline[isAppend ? \"indexOf\" : \"lastIndexOf\"](point);\n      const item = items[i];\n      const columnWidth = item.columnWidth;\n      const column = columnWidth && columnWidth[0] === columnLength && columnWidth[1] || getColumn(item);\n      let columnCount = 1;\n\n      if (column > 1) {\n        for (let j = 1; j < column && (isAppend && index + j < columnLength || !isAppend && index - j >= 0); ++j) {\n          if (isAppend && endOutline[index + sign * j] <= point || !isAppend && endOutline[index + sign * j] >= point) {\n            ++columnCount;\n            continue;\n          }\n\n          break;\n        }\n\n        if (!isAppend) {\n          index -= columnCount - 1;\n        }\n      }\n\n      item.columnWidth = [columnLength, columnCount];\n      shapes.push({\n        width: columnCount,\n        height: columnCount,\n        [pos1Name]: point - (!isAppend ? columnCount : 0),\n        [pos2Name]: index,\n        index: i\n      });\n\n      for (let j = 0; j < columnCount; ++j) {\n        endOutline[index + j] = point + sign * columnCount;\n      }\n    }\n\n    this._shapes = {\n      shapes,\n      [style.size2]: columnLength\n    };\n\n    const result = super._layout(items, outline, isAppend);\n\n    if (!isAppend) {\n      shapes.sort((shape1, shape2) => {\n        const item1pos1 = shape1[pos1Name];\n        const item1pos2 = shape1[pos2Name];\n        const item2pos1 = shape2[pos1Name];\n        const item2pos2 = shape2[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n      items.sort((a, b) => {\n        const item1pos1 = a.rect[pos1Name];\n        const item1pos2 = a.rect[pos2Name];\n        const item2pos1 = b.rect[pos1Name];\n        const item2pos2 = b.rect[pos2Name];\n\n        if (item1pos1 - item2pos1) {\n          return item1pos1 - item2pos1;\n        }\n\n        return item1pos2 - item2pos2;\n      });\n    }\n\n    return result;\n  }\n\n}\n\nexport default SquareLayout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/SquareLayout.js\n// module id = null\n// module chunks = ","export default class BoxModel {\n  constructor(options) {\n    Object.assign(this, {\n      originWidth: 0,\n      originHeight: 0,\n      width: 0,\n      height: 0,\n      left: 0,\n      top: 0,\n      items: []\n    }, options);\n  }\n\n  scaleTo(width, height) {\n    const scaleX = this.width ? width / this.width : 0;\n    const scaleY = this.height ? height / this.height : 0;\n    this.items.forEach(v => {\n      if (scaleX !== 0) {\n        v.left *= scaleX;\n        v.width *= scaleX;\n      }\n\n      if (scaleY !== 0) {\n        v.top *= scaleY;\n        v.height *= scaleY;\n      }\n    });\n    this.width = width;\n    this.height = height;\n  }\n\n  push(item) {\n    this.items.push(item);\n  }\n\n  getOriginSize() {\n    return this.originWidth * this.originHeight;\n  }\n\n  getSize() {\n    return this.width * this.height;\n  }\n\n  getOriginRatio() {\n    return this.originHeight === 0 ? 0 : this.originWidth / this.originHeight;\n  }\n\n  getRatio() {\n    return this.height === 0 ? 0 : this.width / this.height;\n  }\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/lib/BoxModel.js\n// module id = null\n// module chunks = ","import BoxModel from \"./lib/BoxModel.js\";\nimport { APPEND, PREPEND } from \"../consts\";\nimport { getStyleNames, assignOptions, toZeroArray, cloneItems } from \"../utils\";\n\nfunction getCost(originLength, length) {\n  let cost = originLength / length;\n\n  if (cost < 1) {\n    cost = 1 / cost;\n  }\n\n  return cost - 1;\n}\n\nfunction fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical) {\n  item.height = itemFitSize.height;\n  item.width = itemFitSize.width;\n  bestFitArea.height = containerFitSize.height;\n  bestFitArea.width = containerFitSize.width;\n\n  if (layoutVertical) {\n    item.top = bestFitArea.top + bestFitArea.height;\n    item.left = bestFitArea.left;\n  } else {\n    item.left = bestFitArea.left + bestFitArea.width;\n    item.top = bestFitArea.top;\n  }\n}\n/**\n * @classdesc The PackingLayout is a layout that shows the important cards bigger without sacrificing the weight of the cards. Rows and columns are separated so that cards are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * @ko PackingLayout              .              .\n * @class eg.InfiniteGrid.PackingLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.PackingLayout module <ko>eg.InfiniteGrid.PackingLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Boolean} [options.aspectRatio=1] The aspect ratio of the group <ko>     </ko>\n * @param {Boolean} [options.sizeWeight=1] The size weight when placing an image <ko>      </ko>\n * @param {Boolean} [options.ratioWeight=1] The ratio weight when placing an image <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.PackingLayout, {\n\tmargin: 10,\n\taspectRatio: 1,\n\tsizeWeight: 1,\n\tratioWeight: 2,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.PackingLayout({\n\thorizontal: true,\n\tmargin: 10,\n\taspectRatio: 1,\n\tsizeWeight: 1,\n\tratioWeight: 2,\n});\n\n</script>\n```\n **/\n\n\nclass PackingLayout {\n  constructor(options = {}) {\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      aspectRatio: 1,\n      sizeWeight: 1,\n      ratioWeight: 1\n    }, options);\n    this._size = 0;\n    this._style = getStyleNames(this.options.horizontal);\n  }\n\n  _findBestFitArea(container, item) {\n    if (container.getRatio() === 0) {\n      //     \n      container.originWidth = item.width;\n      container.originHeight = item.height;\n      container.width = item.width;\n      container.height = item.height;\n      return;\n    }\n\n    let bestFitArea = null;\n    let minCost = 10000000;\n    let layoutVertical = false;\n    const itemFitSize = {\n      width: 0,\n      height: 0\n    };\n    const containerFitSize = {\n      width: 0,\n      height: 0\n    };\n    const {\n      sizeWeight,\n      ratioWeight\n    } = this.options;\n    container.items.forEach(v => {\n      const containerSizeCost = getCost(v.getOriginSize(), v.getSize()) * sizeWeight;\n      const containerRatioCost = getCost(v.getOriginRatio(), v.getRatio()) * ratioWeight;\n      const width = v.width;\n      const height = v.height;\n      let cost;\n\n      for (let i = 0; i < 2; ++i) {\n        let itemWidth;\n        let itemHeight;\n        let containerWidth;\n        let containerHeight;\n\n        if (i === 0) {\n          //   \n          itemWidth = width;\n          itemHeight = height * (item.height / (v.originHeight + item.height));\n          containerWidth = width;\n          containerHeight = height - itemHeight;\n        } else {\n          //   \n          itemHeight = height;\n          itemWidth = width * (item.width / (v.originWidth + item.width));\n          containerHeight = height;\n          containerWidth = width - itemWidth;\n        }\n\n        const itemSize = itemWidth * itemHeight;\n        const itemRatio = itemWidth / itemHeight;\n        const containerSize = containerWidth * containerHeight;\n        const containerRatio = containerHeight / containerHeight;\n        cost = getCost(item.getSize(), itemSize) * sizeWeight;\n        cost += getCost(item.getRatio(), itemRatio) * ratioWeight;\n        cost += getCost(v.getOriginSize(), containerSize) * sizeWeight - containerSizeCost;\n        cost += getCost(v.getOriginRatio(), containerRatio) * ratioWeight - containerRatioCost;\n\n        if (cost === Math.min(cost, minCost)) {\n          minCost = cost;\n          bestFitArea = v;\n          layoutVertical = i === 0;\n          itemFitSize.width = itemWidth;\n          itemFitSize.height = itemHeight;\n          containerFitSize.width = containerWidth;\n          containerFitSize.height = containerHeight;\n        }\n      }\n    });\n    fitArea(item, bestFitArea, itemFitSize, containerFitSize, layoutVertical);\n  }\n\n  _layout(items, outline = [], isAppend) {\n    const style = this._style;\n    const {\n      horizontal,\n      aspectRatio,\n      margin\n    } = this.options;\n    const pos1Name = style.pos1;\n    const containerWidth = this._size * (horizontal ? aspectRatio : 1);\n    const containerHeight = this._size / (horizontal ? 1 : aspectRatio);\n    const containerSize1 = horizontal ? containerWidth : containerHeight;\n    const prevOutline = toZeroArray(outline);\n    const start = isAppend ? Math.max(...prevOutline) : Math.min(...prevOutline) - containerSize1 - margin;\n    const end = start + containerSize1 + margin;\n    const container = new BoxModel({});\n    items.forEach(item => {\n      const {\n        width,\n        height\n      } = item.orgSize;\n      const model = new BoxModel({\n        width,\n        height,\n        originWidth: width,\n        originHeight: height\n      });\n\n      this._findBestFitArea(container, model);\n\n      container.push(model);\n      container.scaleTo(containerWidth + margin, containerHeight + margin);\n    });\n    items.forEach((item, i) => {\n      const boxItem = container.items[i];\n      const width = boxItem.width;\n      const height = boxItem.height;\n      const top = boxItem.top;\n      const left = boxItem.left;\n      item.rect = {\n        top,\n        left,\n        width: width - margin,\n        height: height - margin\n      };\n      item.rect[pos1Name] += start;\n    });\n    return {\n      start: [start],\n      end: [end]\n    };\n  }\n\n  _insert(items = [], outline = [], type, cache) {\n    // this only needs the size of the item.\n    const clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, type)\n    };\n  }\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  append(items, outline, cache) {\n    return this._insert(items, outline, APPEND, cache);\n  }\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  prepend(items, outline, cache) {\n    return this._insert(items, outline, PREPEND, cache);\n  }\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.PackingLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100, 200, 300, 400]);\n   */\n\n\n  layout(groups = [], outline = []) {\n    const length = groups.length;\n    let point = outline;\n\n    for (let i = 0; i < length; ++i) {\n      const group = groups[i];\n      point = this._layout(group.items, point, APPEND);\n      group.outlines = point;\n      point = point.end;\n    }\n\n    return this;\n  }\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.PackingLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.PackingLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  setSize(size) {\n    this._size = size;\n    return this;\n  }\n\n}\n\nexport default PackingLayout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/PackingLayout.js\n// module id = null\n// module chunks = ","/* eslint-disable */\n\n/******************************************************************************\n * Created 2008-08-19.\n *\n * Dijkstra path-finding functions. Adapted from the Dijkstar Python project.\n *\n * Copyright (C) 2008\n *   Wyatt Baldwin <self@wyattbaldwin.com>\n *   All rights reserved\n *\n * Licensed under the MIT license.\n *\n *   http://www.opensource.org/licenses/mit-license.php\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *****************************************************************************/\nvar dijkstra = {\n  single_source_shortest_paths: function (graph, s, d) {\n    // Predecessor map for each node that has been encountered.\n    // node ID => predecessor node ID\n    var predecessors = {}; // Costs of shortest paths from s to all nodes encountered.\n    // node ID => cost\n\n    var costs = {};\n    costs[s] = 0; // Costs of shortest paths from s to all nodes encountered; differs from\n    // `costs` in that it provides easy access to the node that currently has\n    // the known shortest path from s.\n    // XXX: Do we actually need both `costs` and `open`?\n\n    var open = new BinaryHeap(function (x) {\n      return x.cost;\n    });\n    open.push({\n      value: s,\n      cost: 0\n    });\n    var closest, u, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;\n\n    while (open.size()) {\n      // In the nodes remaining in graph that have a known cost from s,\n      // find the node, u, that currently has the shortest path from s.\n      closest = open.pop();\n      u = closest.value;\n      cost_of_s_to_u = closest.cost; // Get nodes adjacent to u...\n\n      adjacent_nodes = graph(u) || {}; // ...and explore the edges that connect u to those nodes, updating\n      // the cost of the shortest paths to any or all of those nodes as\n      // necessary. v is the node across the current edge from u.\n\n      for (var v in adjacent_nodes) {\n        // Get the cost of the edge running from u to v.\n        cost_of_e = adjacent_nodes[v]; // Cost of s to u plus the cost of u to v across e--this is *a*\n        // cost from s to v that may or may not be less than the current\n        // known cost to v.\n\n        cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e; // If we haven't visited v yet OR if the current known cost from s to\n        // v is greater than the new cost we just found (cost of s to u plus\n        // cost of u to v across e), update v's cost in the cost list and\n        // update v's predecessor in the predecessor list (it's now u).\n\n        cost_of_s_to_v = costs[v];\n        first_visit = typeof costs[v] === 'undefined';\n\n        if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {\n          costs[v] = cost_of_s_to_u_plus_cost_of_e;\n          open.push({\n            value: v,\n            cost: cost_of_s_to_u_plus_cost_of_e\n          });\n          predecessors[v] = u;\n        }\n      }\n    }\n\n    if (typeof costs[d] === 'undefined') {\n      var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('');\n      throw new Error(msg);\n    }\n\n    return predecessors;\n  },\n  extract_shortest_path_from_predecessor_list: function (predecessors, d) {\n    var nodes = [];\n    var u = d;\n    var predecessor;\n\n    while (u) {\n      nodes.push(u);\n      predecessor = predecessors[u];\n      u = predecessors[u];\n    }\n\n    nodes.reverse();\n    return nodes;\n  },\n  find_path: function (graph, s, d) {\n    var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);\n    return dijkstra.extract_shortest_path_from_predecessor_list(predecessors, d);\n  }\n};\n\nclass BinaryHeap {\n  constructor(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push(element) {\n    // Add the new element to the end of the array.\n    this.content.push(element); // Allow it to bubble up.\n\n    this.bubbleUp(this.content.length - 1);\n  }\n\n  pop() {\n    // Store the first element so we can return it later.\n    var result = this.content[0]; // Get the element at the end of the array.\n\n    var end = this.content.pop(); // If there are any elements left, put the end element at the\n    // start, and let it sink down.\n\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.sinkDown(0);\n    }\n\n    return result;\n  }\n\n  size() {\n    return this.content.length;\n  }\n\n  bubbleUp(n) {\n    // Fetch the element that has to be moved.\n    var element = this.content[n]; // When at 0, an element can not go up any further.\n\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN]; // Swap the elements if the parent is greater.\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        this.content[parentN] = element;\n        this.content[n] = parent; // Update 'n' to continue at the new position.\n\n        n = parentN;\n      } // Found a parent that is less, no need to move it further.\n      else {\n          break;\n        }\n    }\n  }\n\n  sinkDown(n) {\n    // Look up the target element and its score.\n    var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      var child2N = (n + 1) * 2,\n          child1N = child2N - 1; // This is used to store the new position of the element,\n      // if any.\n\n      var swap = null; // If the first child exists (is inside the array)...\n\n      if (child1N < length) {\n        // Look it up and compute its score.\n        var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1); // If the score is less than our element's, we need to swap.\n\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      } // Do the same checks for the other child.\n\n\n      if (child2N < length) {\n        var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n\n        if (child2Score < (swap == null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      } // If the element needs to be moved, swap it, and continue.\n\n\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      } // Otherwise, we are done.\n      else {\n          break;\n        }\n    }\n  }\n\n}\n\nexport default dijkstra;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/lib/dijkstra.js\n// module id = null\n// module chunks = ","import dijkstra from \"./lib/dijkstra\";\nimport { APPEND, PREPEND } from \"../consts\";\nimport { getStyleNames, assignOptions, cloneItems } from \"../utils\";\n/**\n * @classdesc 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedLayout is a layout that the card is filled up on the basis of a line given a size.\n * @ko 'justified' '1    '    .           .\n * @class eg.InfiniteGrid.JustifiedLayout\n * @param {Object} [options] The option object of eg.InfiniteGrid.JustifiedLayout module <ko>eg.InfiniteGrid.JustifiedLayout   </ko>\n * @param {String} [options.margin=0] Margin used to create space around items <ko>  </ko>\n * @param {Boolean} [options.horizontal=false] Direction of the scroll movement (false: vertical, true: horizontal) <ko>   (false: , true: )</ko>\n * @param {Number} [options.minSize=0] Minimum size of item to be resized <ko>     </ko>\n * @param {Number} [options.maxSize=0] Maximum size of item to be resized <ko>     </ko>\n * @param {Array|Number} [options.column=[1, 8]] The number of items in a line <ko>      </ko>\n * @example\n```\n<script>\nvar ig = new eg.InfiniteGrid(\"#grid\". {\n\thorizontal: true,\n});\n\nig.setLayout(eg.InfiniteGrid.JustifiedLayout, {\n\tmargin: 10,\n\tminSize: 100,\n\tmaxSize: 300,\n});\n\n// or\n\nvar layout = new eg.InfiniteGrid.JustifiedLayout({\n\tmargin: 10,\n\tminSize: 100,\n\tmaxSize: 300,\n\tcolumn: 5,\n\thorizontal: true,\n});\n\n</script>\n```\n **/\n\nclass JustifiedLayout {\n  constructor(options = {}) {\n    this.options = assignOptions({\n      margin: 0,\n      horizontal: false,\n      minSize: 0,\n      maxSize: 0,\n      column: [1, 8]\n    }, options);\n    this._style = getStyleNames(this.options.horizontal);\n    this._size = 0;\n  }\n\n  _layout(items, outline, isAppend) {\n    const style = this._style;\n    const size1Name = style.size1;\n    const size2Name = style.size2;\n    const startIndex = 0;\n    const endIndex = items.length;\n    let column = this.options.column;\n\n    if (typeof column !== \"object\") {\n      column = [column, column];\n    }\n\n    const graph = _start => {\n      const results = {};\n      const start = +_start.replace(/[^0-9]/g, \"\");\n      const length = endIndex + 1;\n\n      for (let i = Math.min(start + column[0], length - 1); i < length; ++i) {\n        if (i - start > column[1]) {\n          break;\n        }\n\n        let cost = this._getCost(items, start, i, size1Name, size2Name);\n\n        if (cost === null) {\n          continue;\n        }\n\n        if (cost < 0 && i === length - 1) {\n          cost = 0;\n        }\n\n        results[`${i}`] = Math.pow(cost, 2);\n      }\n\n      return results;\n    }; // shortest path for items' total height.\n\n\n    const path = dijkstra.find_path(graph, `${startIndex}`, `${endIndex}`);\n    return this._setStyle(items, path, outline, isAppend);\n  }\n\n  _getSize(items, size1Name, size2Name) {\n    const margin = this.options.margin;\n    const size = items.reduce((sum, item) => sum + item.orgSize[size2Name] / item.orgSize[size1Name], 0);\n    return (this._size - margin * (items.length - 1)) / size;\n  }\n\n  _getCost(items, i, j, size1Name, size2Name) {\n    const size = this._getSize(items.slice(i, j), size1Name, size2Name);\n\n    const min = this.options.minSize || 0;\n    const max = this.options.maxSize || Infinity;\n\n    if (isFinite(max)) {\n      // if this size is not in range, the cost increases sharply.\n      if (size < min) {\n        return Math.pow(size - min, 2) + Math.pow(max, 2);\n      } else if (size > max) {\n        return Math.pow(size - max, 2) + Math.pow(max, 2);\n      } else {\n        // if this size in range, the cost is negative or low.\n        return Math.min(size - max, min - size);\n      }\n    } // if max is infinite type, caculate cost only with \"min\".\n\n\n    if (size < min) {\n      return Math.max(Math.pow(min, 2), Math.pow(size, 2));\n    }\n\n    return size - min;\n  }\n\n  _setStyle(items, path, outline = [], isAppend) {\n    const style = this._style; // if direction is vertical\n    // pos1 : top, pos11 : bottom\n    // size1 : height\n    // pos2 : left, pos22 : right\n    // size2 : width\n    // if direction is horizontal\n    // pos1 : left, pos11 : right\n    // size1 : width\n    // pos2 : top, pos22 : bottom\n    // size2 : height\n\n    const pos1Name = style.pos1;\n    const size1Name = style.size1;\n    const pos2Name = style.pos2;\n    const size2Name = style.size2;\n    const length = path.length;\n    const margin = this.options.margin;\n    const startPoint = outline[0] || 0;\n    let endPoint = startPoint;\n    let height = 0;\n\n    for (let i = 0; i < length - 1; ++i) {\n      const path1 = parseInt(path[i], 10);\n      const path2 = parseInt(path[i + 1], 10); // pathItems(path1 to path2) are in 1 line.\n\n      const pathItems = items.slice(path1, path2);\n      const pathItemsLength = pathItems.length;\n\n      const size1 = this._getSize(pathItems, size1Name, size2Name);\n\n      const pos1 = endPoint;\n\n      for (let j = 0; j < pathItemsLength; ++j) {\n        const item = pathItems[j];\n        const size2 = item.orgSize[size2Name] / item.orgSize[size1Name] * size1; // item has margin bottom and right.\n        // first item has not margin.\n\n        const prevItemRect = j === 0 ? 0 : pathItems[j - 1].rect;\n        const pos2 = prevItemRect ? prevItemRect[pos2Name] + prevItemRect[size2Name] + margin : 0;\n        item.rect = {\n          [pos1Name]: pos1,\n          [pos2Name]: pos2,\n          [size1Name]: size1,\n          [size2Name]: size2\n        };\n      }\n\n      height += margin + size1;\n      endPoint = startPoint + height;\n    }\n\n    const itemsLength = items.length;\n\n    if (isAppend) {\n      // previous group's end outline is current group's start outline\n      return {\n        start: [startPoint],\n        end: [endPoint]\n      };\n    } // for prepend, only substract height from position.\n    // always start is lower than end.\n\n\n    for (let i = 0; i < itemsLength; ++i) {\n      const item = items[i]; // move items as long as height for prepend\n\n      item.rect[pos1Name] -= height;\n    }\n\n    return {\n      start: [startPoint - height],\n      end: [startPoint] // endPoint - height = startPoint\n\n    };\n  }\n\n  _insert(items = [], outline = [], type, cache) {\n    // this only needs the size of the item.\n    const clone = cache ? items : cloneItems(items);\n    return {\n      items: clone,\n      outlines: this._layout(clone, outline, type)\n    };\n  }\n  /**\n   * Set the viewport size of the layout.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#setSize\n   * @param {Number} size The viewport size of container area where items are added to a layout <ko>      </ko>\n   * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.setSize(800);\n   */\n\n\n  setSize(size) {\n    this._size = size;\n    return this;\n  }\n  /**\n   * Adds items at the bottom of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#append\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  append(items, outline, cache) {\n    return this._insert(items, outline, APPEND, cache);\n  }\n  /**\n   * Adds items at the top of a outline.\n   * @ko    .\n   * @method eg.InfiniteGrid.JustifiedLayout#prepend\n   * @param {Array} items Array of items to be layouted <ko>  </ko>\n   * @param {Array} [outline=[]] Array of outline points to be reference points <ko>    </ko>\n   * @return {Object} Layouted items and outline of start and end <ko>        </ko>\n   * @example\n   * layout.prepend(items, [100]);\n   */\n\n\n  prepend(items, outline, cache) {\n    return this._insert(items, outline, PREPEND, cache);\n  }\n  /**\n   * Adds items of groups at the bottom of a outline.\n   * @ko     .\n   * @method eg.InfiniteGrid.JustifiedLayout#layout\n   * @param {Array} groups Array of groups to be layouted <ko>  </ko>\n   * @param {Array} outline Array of outline points to be reference points <ko>    </ko>\n   * @return {eg.InfiniteGrid.JustifiedLayout} An instance of a module itself<ko>  </ko>\n   * @example\n   * layout.layout(groups, [100]);\n   */\n\n\n  layout(groups = [], outline = []) {\n    const length = groups.length;\n    let point = outline;\n\n    for (let i = 0; i < length; ++i) {\n      const group = groups[i];\n      point = this._layout(group.items, point, APPEND);\n      group.outlines = point;\n      point = point.end;\n    }\n\n    return this;\n  }\n\n}\n\nexport default JustifiedLayout;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/layouts/JustifiedLayout.js\n// module id = null\n// module chunks = ","/**\n * Copyright (c) NAVER Corp.\n * egjs-infinitegrid projects are licensed under the MIT license\n */\nimport InfiniteGrid from \"./InfiniteGrid\";\nimport GridLayout from \"./layouts/GridLayout\";\nimport FrameLayout from \"./layouts/FrameLayout\";\nimport SquareLayout from \"./layouts/SquareLayout\";\nimport PackingLayout from \"./layouts/PackingLayout\";\nimport JustifiedLayout from \"./layouts/JustifiedLayout\";\nimport ImageLoaded from \"./ImageLoaded\";\nimport AutoSizer from \"./AutoSizer\";\nimport DOMRenderer from \"./DOMRenderer\";\nimport Watcher from \"./Watcher\";\nimport ItemManager from \"./ItemManager\";\nimport Infinite from \"./Infinite\";\nimport LayoutManager from \"./LayoutManager\";\nexport { default as VERSION } from \"./version\";\nexport { GridLayout, FrameLayout, SquareLayout, PackingLayout, JustifiedLayout, Infinite, ImageLoaded, AutoSizer, DOMRenderer, Watcher, ItemManager, LayoutManager, InfiniteGrid as default };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = null\n// module chunks = ","/*!\n * Copyright (c) 2017 NAVER Corp.\r\n * @egjs/component project is licensed under the MIT license\r\n * \r\n * @egjs/component JavaScript library\r\n * http://naver.github.io/egjs/component\r\n * \r\n * @version 2.1.1\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Component\"] = factory();\n\telse\n\t\troot[\"eg\"] = root[\"eg\"] || {}, root[\"eg\"][\"Component\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 2);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Copyright (c) 2015 NAVER Corp.\n * egjs projects are licensed under the MIT license\n */\n\n/**\n * A class used to manage events in a component\n * @ko       \n * @alias eg.Component\n */\nvar Component = function () {\n\t/**\n  * @support {\"ie\": \"7+\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"2.1+ (except 3.x)\"}\n  */\n\tfunction Component() {\n\t\t_classCallCheck(this, Component);\n\n\t\tthis._eventHandler = {};\n\t\tthis.options = {};\n\t}\n\t/**\n  * Triggers a custom event.\n  * @ko   \n  * @param {String} eventName The name of the custom event to be triggered <ko>   </ko>\n  * @param {Object} customEvent Event data to be sent when triggering a custom event <ko>     </ko>\n  * @return {Boolean} Indicates whether the event has occurred. If the stop() method is called by a custom event handler, it will return false and prevent the event from occurring. <a href=\"https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\">Ref</a> <ko>  .    stop()   'false'    . <a href=\"https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\"></a></ko>\n  * @example\n class Some extends eg.Component {\n  some(){\n  \tif(this.trigger(\"beforeHi\")){ // When event call to stop return false.\n \tthis.trigger(\"hi\");// fire hi event.\n  \t}\n  }\n }\n const some = new Some();\n some.on(\"beforeHi\", (e) => {\n if(condition){\n \te.stop(); // When event call to stop, `hi` event not call.\n }\n });\n some.on(\"hi\", (e) => {\n // `currentTarget` is component instance.\n console.log(some === e.currentTarget); // true\n });\n // If you want to more know event design. You can see article.\n // https://github.com/naver/egjs-component/wiki/How-to-make-Component-event-design%3F\n  */\n\n\n\tComponent.prototype.trigger = function trigger(eventName) {\n\t\tvar customEvent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t\tvar handlerList = this._eventHandler[eventName] || [];\n\t\tvar hasHandlerList = handlerList.length > 0;\n\n\t\tif (!hasHandlerList) {\n\t\t\treturn true;\n\t\t}\n\n\t\t// If detach method call in handler in first time then handler list calls.\n\t\thandlerList = handlerList.concat();\n\n\t\tcustomEvent.eventType = eventName;\n\n\t\tvar isCanceled = false;\n\t\tvar arg = [customEvent];\n\t\tvar i = 0;\n\n\t\tcustomEvent.stop = function () {\n\t\t\tisCanceled = true;\n\t\t};\n\t\tcustomEvent.currentTarget = this;\n\n\t\tfor (var _len = arguments.length, restParam = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n\t\t\trestParam[_key - 2] = arguments[_key];\n\t\t}\n\n\t\tif (restParam.length >= 1) {\n\t\t\targ = arg.concat(restParam);\n\t\t}\n\n\t\tfor (i = 0; handlerList[i]; i++) {\n\t\t\thandlerList[i].apply(this, arg);\n\t\t}\n\n\t\treturn !isCanceled;\n\t};\n\t/**\n  * Executed event just one time.\n  * @ko   .\n  * @param {eventName} eventName The name of the event to be attached <ko>  </ko>\n  * @param {Function} handlerToAttach The handler function of the event to be attached <ko>   </ko>\n  * @return {eg.Component} An instance of a component itself<ko>  </ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    alert(\"hi\");\n  }\n  thing() {\n    this.once(\"hi\", this.hi);\n  }\n }\n var some = new Some();\n some.thing();\n some.trigger(\"hi\");\n // fire alert(\"hi\");\n some.trigger(\"hi\");\n // Nothing happens\n  */\n\n\n\tComponent.prototype.once = function once(eventName, handlerToAttach) {\n\t\tif ((typeof eventName === \"undefined\" ? \"undefined\" : _typeof(eventName)) === \"object\" && typeof handlerToAttach === \"undefined\") {\n\t\t\tvar eventHash = eventName;\n\t\t\tvar i = void 0;\n\n\t\t\tfor (i in eventHash) {\n\t\t\t\tthis.once(i, eventHash[i]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n\t\t\tvar self = this;\n\n\t\t\tthis.on(eventName, function listener() {\n\t\t\t\tfor (var _len2 = arguments.length, arg = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t\t\t\t\targ[_key2] = arguments[_key2];\n\t\t\t\t}\n\n\t\t\t\thandlerToAttach.apply(self, arg);\n\t\t\t\tself.off(eventName, listener);\n\t\t\t});\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n  * Checks whether an event has been attached to a component.\n  * @ko    .\n  * @param {String} eventName The name of the event to be attached <ko>    </ko>\n  * @return {Boolean} Indicates whether the event is attached. <ko>  </ko>\n  * @example\n class Some extends eg.Component {\n  some() {\n    this.hasOn(\"hi\");// check hi event.\n  }\n }\n  */\n\n\n\tComponent.prototype.hasOn = function hasOn(eventName) {\n\t\treturn !!this._eventHandler[eventName];\n\t};\n\n\t/**\n  * Attaches an event to a component.\n  * @ko   .\n  * @param {eventName} eventName The name of the event to be attached <ko>  </ko>\n  * @param {Function} handlerToAttach The handler function of the event to be attached <ko>   </ko>\n  * @return {eg.Component} An instance of a component itself<ko>  </ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    console.log(\"hi\");\n  }\n  some() {\n    this.on(\"hi\",this.hi); //attach event\n  }\n }\n */\n\n\n\tComponent.prototype.on = function on(eventName, handlerToAttach) {\n\t\tif ((typeof eventName === \"undefined\" ? \"undefined\" : _typeof(eventName)) === \"object\" && typeof handlerToAttach === \"undefined\") {\n\t\t\tvar eventHash = eventName;\n\t\t\tvar name = void 0;\n\n\t\t\tfor (name in eventHash) {\n\t\t\t\tthis.on(name, eventHash[name]);\n\t\t\t}\n\t\t\treturn this;\n\t\t} else if (typeof eventName === \"string\" && typeof handlerToAttach === \"function\") {\n\t\t\tvar handlerList = this._eventHandler[eventName];\n\n\t\t\tif (typeof handlerList === \"undefined\") {\n\t\t\t\tthis._eventHandler[eventName] = [];\n\t\t\t\thandlerList = this._eventHandler[eventName];\n\t\t\t}\n\n\t\t\thandlerList.push(handlerToAttach);\n\t\t}\n\n\t\treturn this;\n\t};\n\t/**\n  * Detaches an event from the component.\n  * @ko    \n  * @param {eventName} eventName The name of the event to be detached <ko>  </ko>\n  * @param {Function} handlerToDetach The handler function of the event to be detached <ko>   </ko>\n  * @return {eg.Component} An instance of a component itself <ko>  </ko>\n  * @example\n class Some extends eg.Component {\n  hi() {\n    console.log(\"hi\");\n  }\n  some() {\n    this.off(\"hi\",this.hi); //detach event\n  }\n }\n  */\n\n\n\tComponent.prototype.off = function off(eventName, handlerToDetach) {\n\t\t// All event detach.\n\t\tif (typeof eventName === \"undefined\") {\n\t\t\tthis._eventHandler = {};\n\t\t\treturn this;\n\t\t}\n\n\t\t// All handler of specific event detach.\n\t\tif (typeof handlerToDetach === \"undefined\") {\n\t\t\tif (typeof eventName === \"string\") {\n\t\t\t\tthis._eventHandler[eventName] = undefined;\n\t\t\t\treturn this;\n\t\t\t} else {\n\t\t\t\tvar eventHash = eventName;\n\t\t\t\tvar name = void 0;\n\n\t\t\t\tfor (name in eventHash) {\n\t\t\t\t\tthis.off(name, eventHash[name]);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\n\t\t// The handler of specific event detach.\n\t\tvar handlerList = this._eventHandler[eventName];\n\n\t\tif (handlerList) {\n\t\t\tvar k = void 0;\n\t\t\tvar handlerFunction = void 0;\n\n\t\t\tfor (k = 0; (handlerFunction = handlerList[k]) !== undefined; k++) {\n\t\t\t\tif (handlerFunction === handlerToDetach) {\n\t\t\t\t\thandlerList = handlerList.splice(k, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\treturn Component;\n}();\n\nexports[\"default\"] = Component;\nmodule.exports = exports[\"default\"];\n\n/***/ }),\n/* 1 */,\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.__esModule = true;\n\nvar _Component = __webpack_require__(0);\n\nvar _Component2 = _interopRequireDefault(_Component);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n_Component2[\"default\"].VERSION = \"2.1.1\";\n\nexports[\"default\"] = _Component2[\"default\"];\nmodule.exports = exports[\"default\"];\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=component.module.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/@egjs/component/dist/component.module.js\n// module id = 4\n// module chunks = 0 1","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 5\n// module chunks = 0 1","/**\n * Version info string\n * @ko  \n * @name VERSION\n * @static\n * @type {String}\n * @example\n * eg.InfiniteGrid.VERSION;  // ex) 3.3.3\n * @memberof eg.InfiniteGrid\n */\nmodule.exports = \"3.4.0-snapshot\";\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/version.js\n// module id = 6\n// module chunks = 0 1"],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACdA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnsCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC9RA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC5XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}